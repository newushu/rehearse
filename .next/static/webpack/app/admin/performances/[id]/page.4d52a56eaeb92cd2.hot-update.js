"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/performances/[id]/page",{

/***/ "(app-pages-browser)/./src/components/PositioningPanel.tsx":
/*!*********************************************!*\
  !*** ./src/components/PositioningPanel.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__  auto */ \nconst GRID_COLS = 12;\nconst GRID_ROWS = 9;\nconst CELL_SIZE = 64;\n // Generate initials with conflict detectionfunction generateInitials(name: string, allNames: string[]): string {  if (!name || name.length === 0) return \"?\";    const firstLetter = name.charAt(0).toUpperCase();    // Check if any other name starts with the same letter  const conflicts = allNames.filter(    (n) => n !== name && n.charAt(0).toUpperCase() === firstLetter  );    if (conflicts.length > 0) {    // Use first 2 letters if conflicts exist    return name.slice(0, 2).toUpperCase();  }    return firstLetter;}export function PositioningPanel({  performanceId,  partId,  partName = null,  partDescription = null,  isGroup = true,  onSavePositions,}: PositioningPanelProps) {  const [roster, setRoster] = useState<RosterStudent[]>([]);  const [positions, setPositions] = useState<PositionEntry[]>([]);  const [draggedStudent, setDraggedStudent] = useState<string | null>(null);  const [draggedFromGrid, setDraggedFromGrid] = useState<boolean>(false);  const [loading, setLoading] = useState(true);  const [saving, setSaving] = useState(false);  const [error, setError] = useState<string | null>(null);  const [frontDirection, setFrontDirection] = useState<FrontDirection>(\"bottom\");  const [lastSavedTime, setLastSavedTime] = useState<number>(Date.now());  const autoSaveIntervalRef = React.useRef<NodeJS.Timeout | null>(null);  const hasChangesRef = React.useRef(false);  const [subparts, setSubparts] = useState<Array<{ id: string; title: string; description?: string | null; mode?: string }>>([]);  const [selectedSubpartId, setSelectedSubpartId] = useState<string | null>(null);  const [subpartPositions, setSubpartPositions] = useState<Record<string, PositionEntry[]>>({});  const [subpartOrder, setSubpartOrder] = useState<Record<string, Array<{ id: string; student_id: string; student_name: string }>>>({});  const [draggingOrderId, setDraggingOrderId] = useState<string | null>(null);  const [editingPartName, setEditingPartName] = useState(false);  const [partNameDraft, setPartNameDraft] = useState(partName || \"\");  const [partNameSaving, setPartNameSaving] = useState(false);  const [editingPartNotes, setEditingPartNotes] = useState(false);  const [partNotesDraft, setPartNotesDraft] = useState(partDescription || \"\");  const [partNotesSaving, setPartNotesSaving] = useState(false);  const [sourceOptions, setSourceOptions] = useState<Array<{ key: string; label: string }>>([]);  const [selectedSourceKey, setSelectedSourceKey] = useState(\"\");  const [flipHorizontal, setFlipHorizontal] = useState(false);  const [applyingQuick, setApplyingQuick] = useState(false);  const fetchSubparts = useCallback(async () => {    try {      const subRes = await fetch(`/api/subparts?partId=${partId}`);      if (subRes.ok) {        const subData = await subRes.json();        setSubparts(subData || []);        if ((subData || []).length === 0) {          setSelectedSubpartId(null);        }      }    } catch (err) {      console.error(\"Error fetching subparts:\", err);    }  }, [partId]);  // Fetch roster, existing positions, and performance orientation  useEffect(() => {    async function fetchData() {      try {        // Fetch performance orientation        const perfRes = await fetch(`/api/performances/${performanceId}`);        if (perfRes.ok) {          const perf = await perfRes.json();          if (perf.stage_orientation) {            setFrontDirection(perf.stage_orientation === \"top\" ? \"top\" : \"bottom\");          }        }        // Fetch roster        const rosterRes = await fetch(`/api/performances/${performanceId}/roster`);        if (!rosterRes.ok) throw new Error(\"Failed to fetch roster\");        const rosterData = await rosterRes.json();                // Filter for this part        const partRoster = rosterData.filter(          (s: any) => s.part_id === partId || !s.part_id        );        setRoster(partRoster);        // Fetch subparts        await fetchSubparts();        // Fetch existing positions        const posRes = await fetch(`/api/stage-positions?partId=${partId}`);        if (!posRes.ok) throw new Error(\"Failed to fetch positions\");        const posData = await posRes.json();        setPositions(          posData.map((p: any) => ({            student_id: p.student_id || \"\",            name: p.student_name || \"Unknown\",            x: p.x,            y: p.y,            id: p.id,          }))        );              } catch (err) {        setError(err instanceof Error ? err.message : \"Failed to load data\");      } finally {        setLoading(false);      }    }    fetchData();  }, [performanceId, partId, isGroup, fetchSubparts]);  useEffect(() => {    setPartNameDraft(partName || \"\");  }, [partName]);  useEffect(() => {    setPartNotesDraft(partDescription || \"\");  }, [partDescription]);  useEffect(() => {    const loadSources = async () => {      try {        const res = await fetch(`/api/parts?performanceId=${performanceId}`);        if (!res.ok) return;        const partsData = await res.json();        const partOptions = (partsData || []).map((p: any) => ({          key: `part:${p.id}`,          label: `Part: ${p.name}`,        }));        const subpartsEntries = await Promise.all(          (partsData || []).map(async (p: any) => {            const subRes = await fetch(`/api/subparts?partId=${p.id}`);            if (!subRes.ok) return [];            const subData = await subRes.json();            return (subData || []).map((s: any) => ({              key: `subpart:${s.id}`,              label: `Subpart: ${p.name} â€¢ ${s.title}`,            }));          })        );        const subpartOptions = subpartsEntries.flat();        setSourceOptions([...partOptions, ...subpartOptions]);      } catch (err) {        console.error(\"Error loading position sources:\", err);      }    };    loadSources();  }, [performanceId]);  useEffect(() => {    if (!selectedSubpartId) return;    const fetchSubpartData = async () => {      try {        const [posRes, orderRes] = await Promise.all([          fetch(`/api/subpart-positions?subpartId=${selectedSubpartId}`),          fetch(`/api/subpart-order?subpartId=${selectedSubpartId}`),        ]);        if (posRes.ok) {          const data = await posRes.json();          setSubpartPositions((prev) => ({            ...prev,            [selectedSubpartId]: (data || []).map((p: any) => ({              student_id: p.student_id || \"\",              name: p.student_name || \"Unknown\",              x: p.x,              y: p.y,              id: p.id,            })),          }));        }        if (orderRes.ok) {          const data = await orderRes.json();          setSubpartOrder((prev) => ({            ...prev,            [selectedSubpartId]: (data || []).map((item: any) => ({              id: item.id,              student_id: item.student_id,              student_name: item.student_name || \"Unknown\",            })),          }));        }      } catch (err) {        console.error(\"Error fetching subpart data:\", err);      }    };    fetchSubpartData();  }, [selectedSubpartId]);  // Auto-save effect  useEffect(() => {    const autoSave = async () => {      if (!hasChangesRef.current) return;      try {        setSaving(true);        if (selectedSubpartId && subparts.length > 0) {          const payload = (subpartPositions[selectedSubpartId] || []).map((p) => ({            subpart_id: selectedSubpartId,            student_id: p.student_id,            x: p.x,            y: p.y,          }));          await fetch(\"/api/subpart-positions\", {            method: \"POST\",            headers: { \"Content-Type\": \"application/json\" },            body: JSON.stringify({              subpart_id: selectedSubpartId,              positions: payload,            }),          });        } else {          await onSavePositions(positions);        }                await fetch(`/api/performances/${performanceId}`, {          method: \"PUT\",          headers: { \"Content-Type\": \"application/json\" },          body: JSON.stringify({ stage_orientation: frontDirection }),        });                hasChangesRef.current = false;        setLastSavedTime(Date.now());        setError(null);      } catch (err) {        console.error(\"Auto-save error:\", err);      } finally {        setSaving(false);      }    };    // Set up auto-save interval    autoSaveIntervalRef.current = setInterval(autoSave, 6000);    return () => {      if (autoSaveIntervalRef.current) {        clearInterval(autoSaveIntervalRef.current);      }    };  }, [positions, frontDirection, performanceId, onSavePositions, selectedSubpartId, subparts, subpartPositions]);  const handleDragStart = (studentId: string, fromGrid: boolean = false) => {    setDraggedStudent(studentId);    setDraggedFromGrid(fromGrid);  };  const handleGridDragOver = (e: React.DragEvent) => {    e.preventDefault();    e.dataTransfer.dropEffect = \"move\";  };  const toLogicalY = (displayY: number) =>    frontDirection === \"top\" ? GRID_ROWS - 1 - displayY : displayY;  const toDisplayY = (logicalY: number) =>    frontDirection === \"top\" ? GRID_ROWS - 1 - logicalY : logicalY;  const toLogicalX = (displayX: number) =>    frontDirection === \"top\" ? GRID_COLS - 1 - displayX : displayX;  const toDisplayX = (logicalX: number) =>    frontDirection === \"top\" ? GRID_COLS - 1 - logicalX : logicalX;  const clampToGrid = (value: number, max: number) => {    if (Number.isNaN(value)) return 0;    if (value < 0) return 0;    if (value > max) return max;    return value;  };  const handleGridDrop = async (e: React.DragEvent, x: number, y: number) => {    e.preventDefault();    if (!draggedStudent) return;    if (subparts.length > 0 && !canPosition) return;    let student = roster.find((s) => s.student_id === draggedStudent);        // If dragging from grid, get name from positions    if (draggedFromGrid && !student) {      const pos = positions.find((p) => p.student_id === draggedStudent);      if (pos) {        student = {          student_id: draggedStudent,          name: pos.name,          part_name: null,        };      }    }        if (!student) return;    const activePositions =      selectedSubpartId && subparts.length > 0        ? subpartPositions[selectedSubpartId] || []        : positions;    // Always remove old position first (whether from roster or grid)    const filtered = activePositions.filter((p) => p.student_id !== draggedStudent);    // Add at new position    const newPositions = [      ...filtered,      {        student_id: draggedStudent,        name: student.name,        x: toLogicalX(x),        y: toLogicalY(y),      },    ];    if (selectedSubpartId && subparts.length > 0) {      setSubpartPositions((prev) => ({ ...prev, [selectedSubpartId]: newPositions }));      await addMissingAssignedFromPositions(        newPositions,        subpartOrder[selectedSubpartId] || []      );    } else {      setPositions(newPositions);    }    hasChangesRef.current = true;    setDraggedStudent(null);    setDraggedFromGrid(false);  };  const removeFromStage = (studentId: string) => {    const persistPositions = async (nextPositions: PositionEntry[]) => {      try {        if (selectedSubpartId && subparts.length > 0) {          await fetch(\"/api/subpart-positions\", {            method: \"POST\",            headers: { \"Content-Type\": \"application/json\" },            body: JSON.stringify({              subpart_id: selectedSubpartId,              positions: nextPositions.map((p) => ({                subpart_id: selectedSubpartId,                student_id: p.student_id,                x: p.x,                y: p.y,              })),            }),          });        } else {          await onSavePositions(nextPositions);        }        hasChangesRef.current = false;        setLastSavedTime(Date.now());      } catch (err) {        setError(err instanceof Error ? err.message : \"Failed to save positions\");        hasChangesRef.current = true;      }    };    if (selectedSubpartId && subparts.length > 0) {      const current = subpartPositions[selectedSubpartId] || [];      const nextPositions = current.filter((p) => p.student_id !== studentId);      setSubpartPositions((prev) => ({        ...prev,        [selectedSubpartId]: nextPositions,      }));      persistPositions(nextPositions);    } else {      const nextPositions = positions.filter((p) => p.student_id !== studentId);      setPositions(nextPositions);      persistPositions(nextPositions);    }    hasChangesRef.current = true;  };  const resetPositions = () => {    if (selectedSubpartId && subparts.length > 0) {      setSubpartPositions((prev) => ({ ...prev, [selectedSubpartId]: [] }));    } else {      setPositions([]);    }    hasChangesRef.current = true;  };  const handleSave = async () => {    try {      setSaving(true);      // Save positions    if (selectedSubpartId && subparts.length > 0) {        const payload = (subpartPositions[selectedSubpartId] || []).map((p) => ({          subpart_id: selectedSubpartId,          student_id: p.student_id,          x: p.x,          y: p.y,        }));        await fetch(\"/api/subpart-positions\", {          method: \"POST\",          headers: { \"Content-Type\": \"application/json\" },          body: JSON.stringify({            subpart_id: selectedSubpartId,            positions: payload,          }),        });      } else {        await onSavePositions(positions);      }            // Save stage orientation at performance level      await fetch(`/api/performances/${performanceId}`, {        method: \"PUT\",        headers: { \"Content-Type\": \"application/json\" },        body: JSON.stringify({ stage_orientation: frontDirection }),      });            setError(null);    } catch (err) {      setError(err instanceof Error ? err.message : \"Failed to save positions\");    } finally {      setSaving(false);    }  };  const persistOrder = useCallback(async (items: Array<{ id: string; student_id: string; student_name: string }>) => {    if (!selectedSubpartId) return;    setSubpartOrder((prev) => ({ ...prev, [selectedSubpartId]: items }));    await fetch(\"/api/subpart-order\", {      method: \"POST\",      headers: { \"Content-Type\": \"application/json\" },      body: JSON.stringify(        items.map((item, idx) => ({          subpart_id: selectedSubpartId,          student_id: item.student_id,          order: idx + 1,        }))      ),    });  }, [selectedSubpartId]);  const addToOrder = async (studentId: string, studentName: string) => {    if (!selectedSubpartId) return;    const next = [...orderItems, { id: `temp-${Date.now()}`, student_id: studentId, student_name: studentName }];    await persistOrder(next);  };  const addMissingAssignedFromPositions = useCallback(async (    positionsList: PositionEntry[],    currentItems: Array<{ id: string; student_id: string; student_name: string }>  ) => {    if (!selectedSubpartId) return;    const existing = new Set(currentItems.map((item) => item.student_id));    const missing = positionsList      .filter((pos) => pos.student_id && !existing.has(pos.student_id))      .map((pos) => ({        id: `temp-${Date.now()}-${pos.student_id}`,        student_id: pos.student_id,        student_name: pos.name,      }));    if (missing.length === 0) return;    const next = [...currentItems, ...missing];    await persistOrder(next);  }, [persistOrder, selectedSubpartId]);  useEffect(() => {    if (!selectedSubpartId) return;    const positionsList = subpartPositions[selectedSubpartId] || [];    const items = subpartOrder[selectedSubpartId] || [];    if (positionsList.length === 0) return;    addMissingAssignedFromPositions(positionsList, items);  }, [selectedSubpartId, subpartPositions, subpartOrder, addMissingAssignedFromPositions]);  const loadSourcePositions = async () => {    if (!selectedSourceKey) return [];    const [type, id] = selectedSourceKey.split(\":\");    if (!id) return [];    const url =      type === \"subpart\"        ? `/api/subpart-positions?subpartId=${id}`        : `/api/stage-positions?partId=${id}`;    const res = await fetch(url);    if (!res.ok) {      const text = await res.text();      throw new Error(text || \"Failed to fetch source positions\");    }    const data = await res.json();    return (data || []).map((p: any) => ({      student_id: p.student_id || \"\",      name: p.student_name || \"Unknown\",      x: p.x,      y: p.y,    })) as PositionEntry[];  };  const applyQuickPositions = async () => {    if (!selectedSourceKey) return;    setApplyingQuick(true);    try {      const sourcePositions = await loadSourcePositions();      const mapped = sourcePositions.map((p) => {        const flippedX = flipHorizontal ? GRID_COLS - 1 - p.x : p.x;        return {          ...p,          x: clampToGrid(flippedX, GRID_COLS - 1),          y: clampToGrid(p.y, GRID_ROWS - 1),        };      });      if (selectedSubpartId && subparts.length > 0) {        setSubpartPositions((prev) => ({ ...prev, [selectedSubpartId]: mapped }));        await addMissingAssignedFromPositions(          mapped,          subpartOrder[selectedSubpartId] || []        );        await fetch(\"/api/subpart-positions\", {          method: \"POST\",          headers: { \"Content-Type\": \"application/json\" },          body: JSON.stringify({            subpart_id: selectedSubpartId,            positions: mapped.map((p) => ({              subpart_id: selectedSubpartId,              student_id: p.student_id,              x: p.x,              y: p.y,            })),          }),        });      } else {        setPositions(mapped);        await onSavePositions(mapped);      }      hasChangesRef.current = false;      setLastSavedTime(Date.now());      setError(null);    } catch (err) {      setError(err instanceof Error ? err.message : \"Failed to apply positions\");    } finally {      setApplyingQuick(false);    }  };  const activeSubpart = subparts.find((s) => s.id === selectedSubpartId);  const subpartMode = activeSubpart?.mode || \"position\";  const canPosition = subparts.length === 0 || subpartMode !== \"order\";  const canOrder = subparts.length > 0;  const orderItems = selectedSubpartId ? subpartOrder[selectedSubpartId] || [] : [];  const activePositions =    selectedSubpartId && subparts.length > 0      ? subpartPositions[selectedSubpartId] || []      : positions;  const positionedStudents = new Set(activePositions.map((p) => p.student_id));  const availableStudents = roster;  // Generate legend with initials (deduplicated)  const uniqueStudents = new Map<string, typeof positions[0]>();  activePositions.forEach((pos) => {    if (!uniqueStudents.has(pos.student_id)) {      uniqueStudents.set(pos.student_id, pos);    }  });    const legendData = Array.from(uniqueStudents.values()).map((pos) => ({    student_id: pos.student_id,    name: pos.name,    initials: generateInitials(pos.name, Array.from(uniqueStudents.values()).map((p) => p.name)),  }));  if (loading) {    return <div className=\"text-center py-8\">Loading...</div>;  }  return (    <div className=\"space-y-6\">      {error && (        <div className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded\">          {error}        </div>      )}      <div className=\"grid grid-cols-1 lg:grid-cols-[220px_1fr] gap-6\">        {/* Roster List */}        <div className=\"bg-gray-50 p-4 rounded-lg border border-gray-200\">          <h3 className=\"font-semibold text-gray-900 mb-2\">            Students ({availableStudents.length})          </h3>          <p className=\"text-[11px] text-gray-500 mb-3\">            Positioned students stay here so you can assign them to subparts.          </p>          <div className=\"space-y-2 max-h-96 overflow-y-auto\">            {availableStudents.length === 0 ? (              <p className=\"text-gray-500 text-sm\">No students yet.</p>            ) : (              availableStudents.map((student) => {                const isPositioned = positionedStudents.has(student.student_id);                return (                  <div                    key={student.student_id}                    draggable                    onDragStart={() => handleDragStart(student.student_id, false)}                    className={`p-3 rounded border cursor-move hover:shadow-md transition-all ${                      isPositioned                        ? \"bg-emerald-50 border-emerald-200 hover:border-emerald-300\"                        : \"bg-white border-blue-200 hover:border-blue-400\"                    }`}                  >                    <div className=\"flex items-center justify-between gap-2\">                      <p className=\"font-medium text-sm text-gray-900\">                        {student.name}                      </p>                      {isPositioned && (                        <span className=\"text-[10px] px-2 py-0.5 rounded bg-emerald-100 text-emerald-700 font-semibold\">                          Positioned                        </span>                      )}                    </div>                    {student.part_name && (                      <p className=\"text-xs text-gray-600\">{student.part_name}</p>                    )}                  </div>                );              })            )}          </div>          {canOrder && selectedSubpartId && (            <div className=\"mt-4 border-t border-gray-200 pt-4\">              <h4 className=\"font-medium text-gray-900 mb-2 text-sm\">                Assigned Students              </h4>              <p className=\"text-[11px] text-gray-500 mb-2\">                Drag students here to assign them to this subpart.              </p>              <div                className=\"bg-white p-2 rounded border border-gray-200\"                onDragOver={(e) => e.preventDefault()}                onDrop={async () => {                  if (!draggedStudent) return;                  const student = roster.find((s) => s.student_id === draggedStudent);                  if (!student) return;                  await addToOrder(student.student_id, student.name);                }}              >                <div className=\"space-y-2\">                  {orderItems.length === 0 ? (                    <div className=\"text-xs text-gray-500 border border-dashed border-gray-300 rounded p-2 text-center\">                      Drop students here                    </div>                  ) : (                    orderItems.map((item, idx) => (                      <div                        key={item.id}                        draggable                        onDragStart={() => setDraggingOrderId(item.id)}                        onDragOver={(e) => e.preventDefault()}                        onDrop={async () => {                          if (!draggingOrderId) return;                          const fromIdx = orderItems.findIndex((i) => i.id === draggingOrderId);                          const toIdx = orderItems.findIndex((i) => i.id === item.id);                          if (fromIdx < 0 || toIdx < 0) return;                          const next = [...orderItems];                          const [moved] = next.splice(fromIdx, 1);                          next.splice(toIdx, 0, moved);                          await persistOrder(next);                          setDraggingOrderId(null);                        }}                        className=\"flex items-center justify-between bg-gray-50 border border-gray-200 rounded px-2 py-1\"                      >                        <div className=\"text-xs text-gray-900\">                          <span className=\"text-gray-500 mr-1\">{idx + 1}.</span>                          {item.student_name}                        </div>                        <button                          onClick={async () => {                            const next = orderItems.filter((i) => i.id !== item.id);                            await persistOrder(next);                          }}                          className=\"text-[10px] text-red-600 hover:text-red-800\"                        >                          Remove                        </button>                      </div>                    ))                  )}                </div>              </div>            </div>          )}        </div>        {/* Stage Grid */}        <div>          <div className=\"space-y-4\">            <div className=\"flex flex-wrap items-start justify-between gap-3 mb-4\">              <div>                <div className=\"flex items-center gap-2\">                  <AppLogo size={24} className=\"border border-gray-200 bg-white text-gray-400\" />                  <h3 className=\"font-semibold text-gray-900\">Stage Layout</h3>                  {editingPartName ? (                    <div className=\"flex items-center gap-2\">                      <input                        type=\"text\"                        value={partNameDraft}                        onChange={(e) => setPartNameDraft(e.target.value)}                        className=\"px-2 py-1 border border-gray-300 rounded text-sm\"                      />                      <button                        onClick={async () => {                          if (!partId) return;                          const nextName = partNameDraft.trim();                          if (!nextName) return;                          setPartNameSaving(true);                          try {                            const res = await fetch(`/api/parts/${partId}`, {                              method: \"PUT\",                              headers: { \"Content-Type\": \"application/json\" },                              body: JSON.stringify({ name: nextName }),                            });                            if (!res.ok) throw new Error(\"Failed to update part name\");                            setEditingPartName(false);                          } catch (err) {                            alert(                              err instanceof Error                                ? err.message                                : \"Failed to update part name\"                            );                          } finally {                            setPartNameSaving(false);                          }                        }}                        disabled={partNameSaving}                        className=\"px-2 py-1 bg-green-600 text-white rounded text-xs disabled:bg-gray-400\"                      >                        {partNameSaving ? \"Saving...\" : \"Save\"}                      </button>                      <button                        onClick={() => {                          setEditingPartName(false);                          setPartNameDraft(partName || \"\");                        }}                        className=\"px-2 py-1 bg-gray-300 text-gray-800 rounded text-xs\"                      >                        Cancel                      </button>                    </div>                  ) : (                    <>                      <span className=\"text-sm text-gray-700\">                        {partName ? `- ${partName}` : \"\"}                      </span>                      <button                        onClick={() => setEditingPartName(true)}                        className=\"text-xs text-blue-600 hover:text-blue-800\"                      >                        Edit name                      </button>                    </>                  )}                </div>                <div className=\"mt-2\">                  {editingPartNotes ? (                    <div className=\"space-y-2\">                      <textarea                        value={partNotesDraft}                        onChange={(e) => setPartNotesDraft(e.target.value)}                        rows={2}                        placeholder=\"Add part notes...\"                        className=\"w-full px-2 py-1 border border-gray-300 rounded text-sm\"                      />                      <div className=\"flex items-center gap-2\">                        <button                          onClick={async () => {                            if (!partId) return;                            setPartNotesSaving(true);                            try {                              const res = await fetch(`/api/parts/${partId}`, {                                method: \"PUT\",                                headers: { \"Content-Type\": \"application/json\" },                                body: JSON.stringify({ description: partNotesDraft || null }),                              });                              if (!res.ok) throw new Error(\"Failed to update part notes\");                              setEditingPartNotes(false);                            } catch (err) {                              alert(                                err instanceof Error                                  ? err.message                                  : \"Failed to update part notes\"                              );                            } finally {                              setPartNotesSaving(false);                            }                          }}                          disabled={partNotesSaving}                          className=\"px-2 py-1 bg-green-600 text-white rounded text-xs disabled:bg-gray-400\"                        >                          {partNotesSaving ? \"Saving...\" : \"Save notes\"}                        </button>                        <button                          onClick={() => {                            setEditingPartNotes(false);                            setPartNotesDraft(partDescription || \"\");                          }}                          className=\"px-2 py-1 bg-gray-300 text-gray-800 rounded text-xs\"                        >                          Cancel                        </button>                      </div>                    </div>                  ) : (                    <div className=\"flex items-start gap-2\">                      <p className=\"text-sm text-gray-600\">                        {partDescription ? partDescription : \"No notes yet.\"}                      </p>                      <button                        onClick={() => setEditingPartNotes(true)}                        className=\"text-xs text-blue-600 hover:text-blue-800\"                      >                        Edit notes                      </button>                    </div>                  )}                </div>                <p className=\"text-sm text-gray-600 mt-1\">                  Front of stage: {frontDirection === \"bottom\" ? \"Bottom\" : \"Top\"}                </p>              </div>              {subparts.length > 0 && (                <div className=\"flex items-center gap-2\">                  <span className=\"text-xs text-gray-600\">Subpart</span>                  <select                    value={selectedSubpartId || \"\"}                    onChange={(e) => setSelectedSubpartId(e.target.value)}                    className=\"px-2 py-1 border border-gray-300 rounded text-xs\"                  >                    <option value=\"\">Part positions</option>                    {subparts.map((sub) => (                      <option key={sub.id} value={sub.id}>                        {sub.title}                      </option>                    ))}                  </select>                  {activeSubpart?.description && (                    <span className=\"text-[10px] text-gray-500\">                      {activeSubpart.description}                    </span>                  )}                </div>              )}              <div className=\"flex flex-col items-end gap-2\">                <div className=\"flex items-center gap-3 text-xs\">                  {saving && (                    <span className=\"text-blue-600 font-semibold\">Auto-saving...</span>                  )}                  {!saving && hasChangesRef.current && (                    <span className=\"text-orange-600 font-semibold\">                      Unsaved changes (auto-saves in 6s)                    </span>                  )}                </div>                <div className=\"flex gap-2\">                  <select                    value={frontDirection}                    onChange={(e) => setFrontDirection(e.target.value as FrontDirection)}                    className=\"px-3 py-2 border border-gray-300 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-blue-500\"                  >                    <option value=\"bottom\">Front - Bottom</option>                    <option value=\"top\">Front - Top</option>                  </select>                  <button                    onClick={resetPositions}                    className=\"px-4 py-2 bg-gray-300 text-gray-900 rounded-lg hover:bg-gray-400 font-medium text-sm\"                  >                    Reset All                  </button>                  <button                    onClick={handleSave}                    disabled={saving}                    className=\"px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 disabled:bg-gray-400 font-medium text-sm\"                  >                    {saving ? \"Saving...\" : \"Save Positions\"}                  </button>                </div>              </div>            </div>            {/* Legend */}            {activePositions.length > 0 && (              <div className=\"bg-blue-50 p-3 rounded-lg border border-blue-200\">                <h4 className=\"font-medium text-gray-900 mb-2 text-sm\">Legend</h4>                <div className=\"grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2\">                  {legendData.map((item) => (                    <div key={item.student_id} className=\"flex items-center gap-2 text-sm\">                      <div className=\"w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center text-white text-xs font-bold\">                        {item.initials}                      </div>                      <span className=\"text-gray-700 truncate\">{item.name}</span>                    </div>                  ))}                </div>              </div>            )}            <div className=\"bg-white p-3 rounded-lg border border-gray-200\">              <div className=\"font-medium text-gray-900 text-sm mb-2\">Quick Position</div>              <div className=\"grid grid-cols-1 md:grid-cols-[1fr_auto] gap-2 items-center\">                <select                  value={selectedSourceKey}                  onChange={(e) => setSelectedSourceKey(e.target.value)}                  className=\"px-2 py-1 border border-gray-300 rounded text-sm\"                >                  <option value=\"\">Select a part or subpart...</option>                  {sourceOptions.map((opt) => (                    <option key={opt.key} value={opt.key}>                      {opt.label}                    </option>                  ))}                </select>                <button                  onClick={applyQuickPositions}                  disabled={!selectedSourceKey || applyingQuick}                  className=\"px-3 py-1 bg-blue-600 text-white rounded text-sm disabled:bg-gray-400\"                >                  {applyingQuick ? \"Applying...\" : \"Apply\"}                </button>              </div>              <label className=\"mt-2 flex items-center gap-2 text-xs text-gray-700\">                <input                  type=\"checkbox\"                  checked={flipHorizontal}                  onChange={(e) => setFlipHorizontal(e.target.checked)}                  className=\"h-4 w-4\"                />                Horizontal flip before applying              </label>            </div>            {subparts.length > 0 && (              <div className=\"text-sm text-gray-700 font-medium text-center\">                {activeSubpart?.title || \"Subpart\"}              </div>            )}            {/* Grid */}            <div className=\"flex items-center justify-center gap-3\">              {subparts.length > 0 && canPosition && (                <button                  onClick={() => {                    const idx = subparts.findIndex((s) => s.id === selectedSubpartId);                    if (idx > 0) setSelectedSubpartId(subparts[idx - 1].id);                  }}                  disabled={!selectedSubpartId || subparts.findIndex((s) => s.id === selectedSubpartId) === 0}                  className=\"px-2 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 disabled:opacity-50 text-xs\"                >                  Prev                </button>              )}              <div                className=\"border-2 border-gray-400 bg-gradient-to-b from-amber-100 to-amber-50 relative mx-auto\"                style={{                  width: GRID_COLS * CELL_SIZE,                  height: GRID_ROWS * CELL_SIZE,                  backgroundImage: `                  linear-gradient(rgba(0,0,0,.1) 1px, transparent 1px),                  linear-gradient(90deg, rgba(0,0,0,.1) 1px, transparent 1px)                `,                  backgroundSize: `${CELL_SIZE}px ${CELL_SIZE}px`,                }}                onDragOver={handleGridDragOver}              >              {/* Front of Stage Indicator */}              {frontDirection === \"bottom\" && (                <div className=\"absolute bottom-0 left-0 right-0 h-1 bg-red-500\"></div>              )}              {frontDirection === \"top\" && (                <div className=\"absolute top-0 left-0 right-0 h-1 bg-red-500\"></div>              )}              {/* Front Label */}              <div                className=\"absolute text-red-600 font-bold text-xs bg-white bg-opacity-80 px-2 py-1 rounded\"                style={{                  ...(frontDirection === \"bottom\" && { bottom: 5, left: \"50%\", transform: \"translateX(-50%)\" }),                  ...(frontDirection === \"top\" && { top: 5, left: \"50%\", transform: \"translateX(-50%)\" }),                }}              >                FRONT              </div>              {selectedSubpartId && subparts.length > 0 && activePositions.length === 0 && (                <div className=\"absolute top-8 left-0 right-0 text-center text-2xl font-bold text-gray-500\">                  {activeSubpart?.title || \"Subpart\"}                </div>              )}              {/* Grid Cells */}              {Array.from({ length: GRID_ROWS }).map((_, y) =>                Array.from({ length: GRID_COLS }).map((_, x) => (                  <div                    key={`${x}-${y}`}                    onDrop={(e) => handleGridDrop(e, x, y)}                    onDragOver={handleGridDragOver}                    className=\"absolute cursor-cell hover:bg-blue-100 hover:bg-opacity-30 transition-colors\"                    style={{                      left: x * CELL_SIZE,                      top: y * CELL_SIZE,                      width: CELL_SIZE,                      height: CELL_SIZE,                    }}                  />                ))              )}              {/* Positioned Students */}              {activePositions.map((pos, idx) => {                const initials = generateInitials(pos.name, activePositions.map((p) => p.name));                return (                  <div                    key={pos.id || `${pos.student_id}-${pos.x}-${pos.y}-${idx}`}                    draggable                    onDragStart={() => handleDragStart(pos.student_id, true)}                    className=\"absolute flex items-center justify-center group cursor-move\"                    style={{                      left: toDisplayX(pos.x) * CELL_SIZE,                      top: toDisplayY(pos.y) * CELL_SIZE,                      width: CELL_SIZE,                      height: CELL_SIZE,                    }}                  >                    <div className=\"relative w-10 h-10 bg-blue-500 rounded-full flex items-center justify-center text-white text-xs font-bold shadow-lg group-hover:bg-blue-600 transition-colors\">                      {initials}                      <button                        onClick={() => removeFromStage(pos.student_id)}                        className=\"absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100 transition-opacity hover:bg-red-600\"                        title=\"Remove from stage\"                      >                        x                      </button>                    </div>                    <div className=\"absolute bottom-full mb-1 whitespace-nowrap bg-gray-900 text-white text-xs py-1 px-2 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none\">                      {pos.name}                    </div>                  </div>                );              })}              </div>              {subparts.length > 0 && canPosition && (                <button                  onClick={() => {                    const idx = subparts.findIndex((s) => s.id === selectedSubpartId);                    if (idx >= 0 && idx < subparts.length - 1) setSelectedSubpartId(subparts[idx + 1].id);                  }}                  disabled={!selectedSubpartId || subparts.findIndex((s) => s.id === selectedSubpartId) === subparts.length - 1}                  className=\"px-2 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 disabled:opacity-50 text-xs\"                >                  Next                </button>              )}            </div>            {canOrder && selectedSubpartId && null}            {/* Positioned Students List */}            <div className=\"bg-gray-50 p-4 rounded-lg border border-gray-200\">              <h4 className=\"font-medium text-gray-900 mb-3\">                Positioned ({activePositions.length})              </h4>              <div className=\"grid grid-cols-2 sm:grid-cols-3 gap-2\">                {activePositions.map((pos, idx) => (                  <div                    key={pos.id || `${pos.student_id}-${pos.x}-${pos.y}-${idx}`}                    className=\"bg-white p-2 rounded border border-green-200 text-sm\"                  >                    <p className=\"font-medium text-gray-900\">{pos.name}</p>                    <p className=\"text-xs text-gray-600\">                      ({pos.x}, {pos.y})                    </p>                  </div>                ))}              </div>            </div>          </div>        </div>      </div>    </div>  );}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1Bvc2l0aW9uaW5nUGFuZWwudHN4IiwibWFwcGluZ3MiOiI7OztzREFBNkU7QUFBeWMsTUFBTUMsWUFBWTtBQUFHLE1BQU1DLFlBQVk7QUFBRSxNQUFNQyxZQUFZO0NBQTBDLHFueUNBQXFueUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2FsdmlcXERlc2t0b3BcXFBlcmZUb29sXFxzcmNcXGNvbXBvbmVudHNcXFBvc2l0aW9uaW5nUGFuZWwudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO2ltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO2ltcG9ydCB7IEFwcExvZ28gfSBmcm9tIFwiQC9jb21wb25lbnRzL0FwcExvZ29cIjtpbnRlcmZhY2UgUm9zdGVyU3R1ZGVudCB7ICBzdHVkZW50X2lkOiBzdHJpbmc7ICBuYW1lOiBzdHJpbmc7ICBwYXJ0X25hbWU6IHN0cmluZyB8IG51bGw7fWludGVyZmFjZSBQb3NpdGlvbkVudHJ5IHsgIHN0dWRlbnRfaWQ6IHN0cmluZzsgIG5hbWU6IHN0cmluZzsgIHg6IG51bWJlcjsgIHk6IG51bWJlcjsgIGlkPzogc3RyaW5nO31pbnRlcmZhY2UgUG9zaXRpb25pbmdQYW5lbFByb3BzIHsgIHBlcmZvcm1hbmNlSWQ6IHN0cmluZzsgIHBhcnRJZDogc3RyaW5nOyAgcGFydE5hbWU/OiBzdHJpbmcgfCBudWxsOyAgcGFydERlc2NyaXB0aW9uPzogc3RyaW5nIHwgbnVsbDsgIGlzR3JvdXA/OiBib29sZWFuOyAgb25TYXZlUG9zaXRpb25zOiAocG9zaXRpb25zOiBQb3NpdGlvbkVudHJ5W10pID0+IFByb21pc2U8dm9pZD47fWNvbnN0IEdSSURfQ09MUyA9IDEyO2NvbnN0IEdSSURfUk9XUyA9IDk7Y29uc3QgQ0VMTF9TSVpFID0gNjQ7dHlwZSBGcm9udERpcmVjdGlvbiA9IFwiYm90dG9tXCIgfCBcInRvcFwiOy8vIEdlbmVyYXRlIGluaXRpYWxzIHdpdGggY29uZmxpY3QgZGV0ZWN0aW9uZnVuY3Rpb24gZ2VuZXJhdGVJbml0aWFscyhuYW1lOiBzdHJpbmcsIGFsbE5hbWVzOiBzdHJpbmdbXSk6IHN0cmluZyB7ICBpZiAoIW5hbWUgfHwgbmFtZS5sZW5ndGggPT09IDApIHJldHVybiBcIj9cIjsgICAgY29uc3QgZmlyc3RMZXR0ZXIgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpOyAgICAvLyBDaGVjayBpZiBhbnkgb3RoZXIgbmFtZSBzdGFydHMgd2l0aCB0aGUgc2FtZSBsZXR0ZXIgIGNvbnN0IGNvbmZsaWN0cyA9IGFsbE5hbWVzLmZpbHRlciggICAgKG4pID0+IG4gIT09IG5hbWUgJiYgbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSA9PT0gZmlyc3RMZXR0ZXIgICk7ICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCkgeyAgICAvLyBVc2UgZmlyc3QgMiBsZXR0ZXJzIGlmIGNvbmZsaWN0cyBleGlzdCAgICByZXR1cm4gbmFtZS5zbGljZSgwLCAyKS50b1VwcGVyQ2FzZSgpOyAgfSAgICByZXR1cm4gZmlyc3RMZXR0ZXI7fWV4cG9ydCBmdW5jdGlvbiBQb3NpdGlvbmluZ1BhbmVsKHsgIHBlcmZvcm1hbmNlSWQsICBwYXJ0SWQsICBwYXJ0TmFtZSA9IG51bGwsICBwYXJ0RGVzY3JpcHRpb24gPSBudWxsLCAgaXNHcm91cCA9IHRydWUsICBvblNhdmVQb3NpdGlvbnMsfTogUG9zaXRpb25pbmdQYW5lbFByb3BzKSB7ICBjb25zdCBbcm9zdGVyLCBzZXRSb3N0ZXJdID0gdXNlU3RhdGU8Um9zdGVyU3R1ZGVudFtdPihbXSk7ICBjb25zdCBbcG9zaXRpb25zLCBzZXRQb3NpdGlvbnNdID0gdXNlU3RhdGU8UG9zaXRpb25FbnRyeVtdPihbXSk7ICBjb25zdCBbZHJhZ2dlZFN0dWRlbnQsIHNldERyYWdnZWRTdHVkZW50XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpOyAgY29uc3QgW2RyYWdnZWRGcm9tR3JpZCwgc2V0RHJhZ2dlZEZyb21HcmlkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTsgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpOyAgY29uc3QgW3NhdmluZywgc2V0U2F2aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTsgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7ICBjb25zdCBbZnJvbnREaXJlY3Rpb24sIHNldEZyb250RGlyZWN0aW9uXSA9IHVzZVN0YXRlPEZyb250RGlyZWN0aW9uPihcImJvdHRvbVwiKTsgIGNvbnN0IFtsYXN0U2F2ZWRUaW1lLCBzZXRMYXN0U2F2ZWRUaW1lXSA9IHVzZVN0YXRlPG51bWJlcj4oRGF0ZS5ub3coKSk7ICBjb25zdCBhdXRvU2F2ZUludGVydmFsUmVmID0gUmVhY3QudXNlUmVmPE5vZGVKUy5UaW1lb3V0IHwgbnVsbD4obnVsbCk7ICBjb25zdCBoYXNDaGFuZ2VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTsgIGNvbnN0IFtzdWJwYXJ0cywgc2V0U3VicGFydHNdID0gdXNlU3RhdGU8QXJyYXk8eyBpZDogc3RyaW5nOyB0aXRsZTogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZyB8IG51bGw7IG1vZGU/OiBzdHJpbmcgfT4+KFtdKTsgIGNvbnN0IFtzZWxlY3RlZFN1YnBhcnRJZCwgc2V0U2VsZWN0ZWRTdWJwYXJ0SWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7ICBjb25zdCBbc3VicGFydFBvc2l0aW9ucywgc2V0U3VicGFydFBvc2l0aW9uc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBQb3NpdGlvbkVudHJ5W10+Pih7fSk7ICBjb25zdCBbc3VicGFydE9yZGVyLCBzZXRTdWJwYXJ0T3JkZXJdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgQXJyYXk8eyBpZDogc3RyaW5nOyBzdHVkZW50X2lkOiBzdHJpbmc7IHN0dWRlbnRfbmFtZTogc3RyaW5nIH0+Pj4oe30pOyAgY29uc3QgW2RyYWdnaW5nT3JkZXJJZCwgc2V0RHJhZ2dpbmdPcmRlcklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpOyAgY29uc3QgW2VkaXRpbmdQYXJ0TmFtZSwgc2V0RWRpdGluZ1BhcnROYW1lXSA9IHVzZVN0YXRlKGZhbHNlKTsgIGNvbnN0IFtwYXJ0TmFtZURyYWZ0LCBzZXRQYXJ0TmFtZURyYWZ0XSA9IHVzZVN0YXRlKHBhcnROYW1lIHx8IFwiXCIpOyAgY29uc3QgW3BhcnROYW1lU2F2aW5nLCBzZXRQYXJ0TmFtZVNhdmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7ICBjb25zdCBbZWRpdGluZ1BhcnROb3Rlcywgc2V0RWRpdGluZ1BhcnROb3Rlc10gPSB1c2VTdGF0ZShmYWxzZSk7ICBjb25zdCBbcGFydE5vdGVzRHJhZnQsIHNldFBhcnROb3Rlc0RyYWZ0XSA9IHVzZVN0YXRlKHBhcnREZXNjcmlwdGlvbiB8fCBcIlwiKTsgIGNvbnN0IFtwYXJ0Tm90ZXNTYXZpbmcsIHNldFBhcnROb3Rlc1NhdmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7ICBjb25zdCBbc291cmNlT3B0aW9ucywgc2V0U291cmNlT3B0aW9uc10gPSB1c2VTdGF0ZTxBcnJheTx7IGtleTogc3RyaW5nOyBsYWJlbDogc3RyaW5nIH0+PihbXSk7ICBjb25zdCBbc2VsZWN0ZWRTb3VyY2VLZXksIHNldFNlbGVjdGVkU291cmNlS2V5XSA9IHVzZVN0YXRlKFwiXCIpOyAgY29uc3QgW2ZsaXBIb3Jpem9udGFsLCBzZXRGbGlwSG9yaXpvbnRhbF0gPSB1c2VTdGF0ZShmYWxzZSk7ICBjb25zdCBbYXBwbHlpbmdRdWljaywgc2V0QXBwbHlpbmdRdWlja10gPSB1c2VTdGF0ZShmYWxzZSk7ICBjb25zdCBmZXRjaFN1YnBhcnRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4geyAgICB0cnkgeyAgICAgIGNvbnN0IHN1YlJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL3N1YnBhcnRzP3BhcnRJZD0ke3BhcnRJZH1gKTsgICAgICBpZiAoc3ViUmVzLm9rKSB7ICAgICAgICBjb25zdCBzdWJEYXRhID0gYXdhaXQgc3ViUmVzLmpzb24oKTsgICAgICAgIHNldFN1YnBhcnRzKHN1YkRhdGEgfHwgW10pOyAgICAgICAgaWYgKChzdWJEYXRhIHx8IFtdKS5sZW5ndGggPT09IDApIHsgICAgICAgICAgc2V0U2VsZWN0ZWRTdWJwYXJ0SWQobnVsbCk7ICAgICAgICB9ICAgICAgfSAgICB9IGNhdGNoIChlcnIpIHsgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgc3VicGFydHM6XCIsIGVycik7ICAgIH0gIH0sIFtwYXJ0SWRdKTsgIC8vIEZldGNoIHJvc3RlciwgZXhpc3RpbmcgcG9zaXRpb25zLCBhbmQgcGVyZm9ybWFuY2Ugb3JpZW50YXRpb24gIHVzZUVmZmVjdCgoKSA9PiB7ICAgIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHsgICAgICB0cnkgeyAgICAgICAgLy8gRmV0Y2ggcGVyZm9ybWFuY2Ugb3JpZW50YXRpb24gICAgICAgIGNvbnN0IHBlcmZSZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9wZXJmb3JtYW5jZXMvJHtwZXJmb3JtYW5jZUlkfWApOyAgICAgICAgaWYgKHBlcmZSZXMub2spIHsgICAgICAgICAgY29uc3QgcGVyZiA9IGF3YWl0IHBlcmZSZXMuanNvbigpOyAgICAgICAgICBpZiAocGVyZi5zdGFnZV9vcmllbnRhdGlvbikgeyAgICAgICAgICAgIHNldEZyb250RGlyZWN0aW9uKHBlcmYuc3RhZ2Vfb3JpZW50YXRpb24gPT09IFwidG9wXCIgPyBcInRvcFwiIDogXCJib3R0b21cIik7ICAgICAgICAgIH0gICAgICAgIH0gICAgICAgIC8vIEZldGNoIHJvc3RlciAgICAgICAgY29uc3Qgcm9zdGVyUmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvcGVyZm9ybWFuY2VzLyR7cGVyZm9ybWFuY2VJZH0vcm9zdGVyYCk7ICAgICAgICBpZiAoIXJvc3RlclJlcy5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIHJvc3RlclwiKTsgICAgICAgIGNvbnN0IHJvc3RlckRhdGEgPSBhd2FpdCByb3N0ZXJSZXMuanNvbigpOyAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZm9yIHRoaXMgcGFydCAgICAgICAgY29uc3QgcGFydFJvc3RlciA9IHJvc3RlckRhdGEuZmlsdGVyKCAgICAgICAgICAoczogYW55KSA9PiBzLnBhcnRfaWQgPT09IHBhcnRJZCB8fCAhcy5wYXJ0X2lkICAgICAgICApOyAgICAgICAgc2V0Um9zdGVyKHBhcnRSb3N0ZXIpOyAgICAgICAgLy8gRmV0Y2ggc3VicGFydHMgICAgICAgIGF3YWl0IGZldGNoU3VicGFydHMoKTsgICAgICAgIC8vIEZldGNoIGV4aXN0aW5nIHBvc2l0aW9ucyAgICAgICAgY29uc3QgcG9zUmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvc3RhZ2UtcG9zaXRpb25zP3BhcnRJZD0ke3BhcnRJZH1gKTsgICAgICAgIGlmICghcG9zUmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggcG9zaXRpb25zXCIpOyAgICAgICAgY29uc3QgcG9zRGF0YSA9IGF3YWl0IHBvc1Jlcy5qc29uKCk7ICAgICAgICBzZXRQb3NpdGlvbnMoICAgICAgICAgIHBvc0RhdGEubWFwKChwOiBhbnkpID0+ICh7ICAgICAgICAgICAgc3R1ZGVudF9pZDogcC5zdHVkZW50X2lkIHx8IFwiXCIsICAgICAgICAgICAgbmFtZTogcC5zdHVkZW50X25hbWUgfHwgXCJVbmtub3duXCIsICAgICAgICAgICAgeDogcC54LCAgICAgICAgICAgIHk6IHAueSwgICAgICAgICAgICBpZDogcC5pZCwgICAgICAgICAgfSkpICAgICAgICApOyAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7ICAgICAgICBzZXRFcnJvcihlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJGYWlsZWQgdG8gbG9hZCBkYXRhXCIpOyAgICAgIH0gZmluYWxseSB7ICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTsgICAgICB9ICAgIH0gICAgZmV0Y2hEYXRhKCk7ICB9LCBbcGVyZm9ybWFuY2VJZCwgcGFydElkLCBpc0dyb3VwLCBmZXRjaFN1YnBhcnRzXSk7ICB1c2VFZmZlY3QoKCkgPT4geyAgICBzZXRQYXJ0TmFtZURyYWZ0KHBhcnROYW1lIHx8IFwiXCIpOyAgfSwgW3BhcnROYW1lXSk7ICB1c2VFZmZlY3QoKCkgPT4geyAgICBzZXRQYXJ0Tm90ZXNEcmFmdChwYXJ0RGVzY3JpcHRpb24gfHwgXCJcIik7ICB9LCBbcGFydERlc2NyaXB0aW9uXSk7ICB1c2VFZmZlY3QoKCkgPT4geyAgICBjb25zdCBsb2FkU291cmNlcyA9IGFzeW5jICgpID0+IHsgICAgICB0cnkgeyAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvcGFydHM/cGVyZm9ybWFuY2VJZD0ke3BlcmZvcm1hbmNlSWR9YCk7ICAgICAgICBpZiAoIXJlcy5vaykgcmV0dXJuOyAgICAgICAgY29uc3QgcGFydHNEYXRhID0gYXdhaXQgcmVzLmpzb24oKTsgICAgICAgIGNvbnN0IHBhcnRPcHRpb25zID0gKHBhcnRzRGF0YSB8fCBbXSkubWFwKChwOiBhbnkpID0+ICh7ICAgICAgICAgIGtleTogYHBhcnQ6JHtwLmlkfWAsICAgICAgICAgIGxhYmVsOiBgUGFydDogJHtwLm5hbWV9YCwgICAgICAgIH0pKTsgICAgICAgIGNvbnN0IHN1YnBhcnRzRW50cmllcyA9IGF3YWl0IFByb21pc2UuYWxsKCAgICAgICAgICAocGFydHNEYXRhIHx8IFtdKS5tYXAoYXN5bmMgKHA6IGFueSkgPT4geyAgICAgICAgICAgIGNvbnN0IHN1YlJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL3N1YnBhcnRzP3BhcnRJZD0ke3AuaWR9YCk7ICAgICAgICAgICAgaWYgKCFzdWJSZXMub2spIHJldHVybiBbXTsgICAgICAgICAgICBjb25zdCBzdWJEYXRhID0gYXdhaXQgc3ViUmVzLmpzb24oKTsgICAgICAgICAgICByZXR1cm4gKHN1YkRhdGEgfHwgW10pLm1hcCgoczogYW55KSA9PiAoeyAgICAgICAgICAgICAga2V5OiBgc3VicGFydDoke3MuaWR9YCwgICAgICAgICAgICAgIGxhYmVsOiBgU3VicGFydDogJHtwLm5hbWV9IOKAoiAke3MudGl0bGV9YCwgICAgICAgICAgICB9KSk7ICAgICAgICAgIH0pICAgICAgICApOyAgICAgICAgY29uc3Qgc3VicGFydE9wdGlvbnMgPSBzdWJwYXJ0c0VudHJpZXMuZmxhdCgpOyAgICAgICAgc2V0U291cmNlT3B0aW9ucyhbLi4ucGFydE9wdGlvbnMsIC4uLnN1YnBhcnRPcHRpb25zXSk7ICAgICAgfSBjYXRjaCAoZXJyKSB7ICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgbG9hZGluZyBwb3NpdGlvbiBzb3VyY2VzOlwiLCBlcnIpOyAgICAgIH0gICAgfTsgICAgbG9hZFNvdXJjZXMoKTsgIH0sIFtwZXJmb3JtYW5jZUlkXSk7ICB1c2VFZmZlY3QoKCkgPT4geyAgICBpZiAoIXNlbGVjdGVkU3VicGFydElkKSByZXR1cm47ICAgIGNvbnN0IGZldGNoU3VicGFydERhdGEgPSBhc3luYyAoKSA9PiB7ICAgICAgdHJ5IHsgICAgICAgIGNvbnN0IFtwb3NSZXMsIG9yZGVyUmVzXSA9IGF3YWl0IFByb21pc2UuYWxsKFsgICAgICAgICAgZmV0Y2goYC9hcGkvc3VicGFydC1wb3NpdGlvbnM/c3VicGFydElkPSR7c2VsZWN0ZWRTdWJwYXJ0SWR9YCksICAgICAgICAgIGZldGNoKGAvYXBpL3N1YnBhcnQtb3JkZXI/c3VicGFydElkPSR7c2VsZWN0ZWRTdWJwYXJ0SWR9YCksICAgICAgICBdKTsgICAgICAgIGlmIChwb3NSZXMub2spIHsgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBvc1Jlcy5qc29uKCk7ICAgICAgICAgIHNldFN1YnBhcnRQb3NpdGlvbnMoKHByZXYpID0+ICh7ICAgICAgICAgICAgLi4ucHJldiwgICAgICAgICAgICBbc2VsZWN0ZWRTdWJwYXJ0SWRdOiAoZGF0YSB8fCBbXSkubWFwKChwOiBhbnkpID0+ICh7ICAgICAgICAgICAgICBzdHVkZW50X2lkOiBwLnN0dWRlbnRfaWQgfHwgXCJcIiwgICAgICAgICAgICAgIG5hbWU6IHAuc3R1ZGVudF9uYW1lIHx8IFwiVW5rbm93blwiLCAgICAgICAgICAgICAgeDogcC54LCAgICAgICAgICAgICAgeTogcC55LCAgICAgICAgICAgICAgaWQ6IHAuaWQsICAgICAgICAgICAgfSkpLCAgICAgICAgICB9KSk7ICAgICAgICB9ICAgICAgICBpZiAob3JkZXJSZXMub2spIHsgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IG9yZGVyUmVzLmpzb24oKTsgICAgICAgICAgc2V0U3VicGFydE9yZGVyKChwcmV2KSA9PiAoeyAgICAgICAgICAgIC4uLnByZXYsICAgICAgICAgICAgW3NlbGVjdGVkU3VicGFydElkXTogKGRhdGEgfHwgW10pLm1hcCgoaXRlbTogYW55KSA9PiAoeyAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsICAgICAgICAgICAgICBzdHVkZW50X2lkOiBpdGVtLnN0dWRlbnRfaWQsICAgICAgICAgICAgICBzdHVkZW50X25hbWU6IGl0ZW0uc3R1ZGVudF9uYW1lIHx8IFwiVW5rbm93blwiLCAgICAgICAgICAgIH0pKSwgICAgICAgICAgfSkpOyAgICAgICAgfSAgICAgIH0gY2F0Y2ggKGVycikgeyAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHN1YnBhcnQgZGF0YTpcIiwgZXJyKTsgICAgICB9ICAgIH07ICAgIGZldGNoU3VicGFydERhdGEoKTsgIH0sIFtzZWxlY3RlZFN1YnBhcnRJZF0pOyAgLy8gQXV0by1zYXZlIGVmZmVjdCAgdXNlRWZmZWN0KCgpID0+IHsgICAgY29uc3QgYXV0b1NhdmUgPSBhc3luYyAoKSA9PiB7ICAgICAgaWYgKCFoYXNDaGFuZ2VzUmVmLmN1cnJlbnQpIHJldHVybjsgICAgICB0cnkgeyAgICAgICAgc2V0U2F2aW5nKHRydWUpOyAgICAgICAgaWYgKHNlbGVjdGVkU3VicGFydElkICYmIHN1YnBhcnRzLmxlbmd0aCA+IDApIHsgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IChzdWJwYXJ0UG9zaXRpb25zW3NlbGVjdGVkU3VicGFydElkXSB8fCBbXSkubWFwKChwKSA9PiAoeyAgICAgICAgICAgIHN1YnBhcnRfaWQ6IHNlbGVjdGVkU3VicGFydElkLCAgICAgICAgICAgIHN0dWRlbnRfaWQ6IHAuc3R1ZGVudF9pZCwgICAgICAgICAgICB4OiBwLngsICAgICAgICAgICAgeTogcC55LCAgICAgICAgICB9KSk7ICAgICAgICAgIGF3YWl0IGZldGNoKFwiL2FwaS9zdWJwYXJ0LXBvc2l0aW9uc1wiLCB7ICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIiwgICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyAgICAgICAgICAgICAgc3VicGFydF9pZDogc2VsZWN0ZWRTdWJwYXJ0SWQsICAgICAgICAgICAgICBwb3NpdGlvbnM6IHBheWxvYWQsICAgICAgICAgICAgfSksICAgICAgICAgIH0pOyAgICAgICAgfSBlbHNlIHsgICAgICAgICAgYXdhaXQgb25TYXZlUG9zaXRpb25zKHBvc2l0aW9ucyk7ICAgICAgICB9ICAgICAgICAgICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL3BlcmZvcm1hbmNlcy8ke3BlcmZvcm1hbmNlSWR9YCwgeyAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzdGFnZV9vcmllbnRhdGlvbjogZnJvbnREaXJlY3Rpb24gfSksICAgICAgICB9KTsgICAgICAgICAgICAgICAgaGFzQ2hhbmdlc1JlZi5jdXJyZW50ID0gZmFsc2U7ICAgICAgICBzZXRMYXN0U2F2ZWRUaW1lKERhdGUubm93KCkpOyAgICAgICAgc2V0RXJyb3IobnVsbCk7ICAgICAgfSBjYXRjaCAoZXJyKSB7ICAgICAgICBjb25zb2xlLmVycm9yKFwiQXV0by1zYXZlIGVycm9yOlwiLCBlcnIpOyAgICAgIH0gZmluYWxseSB7ICAgICAgICBzZXRTYXZpbmcoZmFsc2UpOyAgICAgIH0gICAgfTsgICAgLy8gU2V0IHVwIGF1dG8tc2F2ZSBpbnRlcnZhbCAgICBhdXRvU2F2ZUludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChhdXRvU2F2ZSwgNjAwMCk7ICAgIHJldHVybiAoKSA9PiB7ICAgICAgaWYgKGF1dG9TYXZlSW50ZXJ2YWxSZWYuY3VycmVudCkgeyAgICAgICAgY2xlYXJJbnRlcnZhbChhdXRvU2F2ZUludGVydmFsUmVmLmN1cnJlbnQpOyAgICAgIH0gICAgfTsgIH0sIFtwb3NpdGlvbnMsIGZyb250RGlyZWN0aW9uLCBwZXJmb3JtYW5jZUlkLCBvblNhdmVQb3NpdGlvbnMsIHNlbGVjdGVkU3VicGFydElkLCBzdWJwYXJ0cywgc3VicGFydFBvc2l0aW9uc10pOyAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKHN0dWRlbnRJZDogc3RyaW5nLCBmcm9tR3JpZDogYm9vbGVhbiA9IGZhbHNlKSA9PiB7ICAgIHNldERyYWdnZWRTdHVkZW50KHN0dWRlbnRJZCk7ICAgIHNldERyYWdnZWRGcm9tR3JpZChmcm9tR3JpZCk7ICB9OyAgY29uc3QgaGFuZGxlR3JpZERyYWdPdmVyID0gKGU6IFJlYWN0LkRyYWdFdmVudCkgPT4geyAgICBlLnByZXZlbnREZWZhdWx0KCk7ICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSBcIm1vdmVcIjsgIH07ICBjb25zdCB0b0xvZ2ljYWxZID0gKGRpc3BsYXlZOiBudW1iZXIpID0+ICAgIGZyb250RGlyZWN0aW9uID09PSBcInRvcFwiID8gR1JJRF9ST1dTIC0gMSAtIGRpc3BsYXlZIDogZGlzcGxheVk7ICBjb25zdCB0b0Rpc3BsYXlZID0gKGxvZ2ljYWxZOiBudW1iZXIpID0+ICAgIGZyb250RGlyZWN0aW9uID09PSBcInRvcFwiID8gR1JJRF9ST1dTIC0gMSAtIGxvZ2ljYWxZIDogbG9naWNhbFk7ICBjb25zdCB0b0xvZ2ljYWxYID0gKGRpc3BsYXlYOiBudW1iZXIpID0+ICAgIGZyb250RGlyZWN0aW9uID09PSBcInRvcFwiID8gR1JJRF9DT0xTIC0gMSAtIGRpc3BsYXlYIDogZGlzcGxheVg7ICBjb25zdCB0b0Rpc3BsYXlYID0gKGxvZ2ljYWxYOiBudW1iZXIpID0+ICAgIGZyb250RGlyZWN0aW9uID09PSBcInRvcFwiID8gR1JJRF9DT0xTIC0gMSAtIGxvZ2ljYWxYIDogbG9naWNhbFg7ICBjb25zdCBjbGFtcFRvR3JpZCA9ICh2YWx1ZTogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4geyAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSkgcmV0dXJuIDA7ICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiAwOyAgICBpZiAodmFsdWUgPiBtYXgpIHJldHVybiBtYXg7ICAgIHJldHVybiB2YWx1ZTsgIH07ICBjb25zdCBoYW5kbGVHcmlkRHJvcCA9IGFzeW5jIChlOiBSZWFjdC5EcmFnRXZlbnQsIHg6IG51bWJlciwgeTogbnVtYmVyKSA9PiB7ICAgIGUucHJldmVudERlZmF1bHQoKTsgICAgaWYgKCFkcmFnZ2VkU3R1ZGVudCkgcmV0dXJuOyAgICBpZiAoc3VicGFydHMubGVuZ3RoID4gMCAmJiAhY2FuUG9zaXRpb24pIHJldHVybjsgICAgbGV0IHN0dWRlbnQgPSByb3N0ZXIuZmluZCgocykgPT4gcy5zdHVkZW50X2lkID09PSBkcmFnZ2VkU3R1ZGVudCk7ICAgICAgICAvLyBJZiBkcmFnZ2luZyBmcm9tIGdyaWQsIGdldCBuYW1lIGZyb20gcG9zaXRpb25zICAgIGlmIChkcmFnZ2VkRnJvbUdyaWQgJiYgIXN0dWRlbnQpIHsgICAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnMuZmluZCgocCkgPT4gcC5zdHVkZW50X2lkID09PSBkcmFnZ2VkU3R1ZGVudCk7ICAgICAgaWYgKHBvcykgeyAgICAgICAgc3R1ZGVudCA9IHsgICAgICAgICAgc3R1ZGVudF9pZDogZHJhZ2dlZFN0dWRlbnQsICAgICAgICAgIG5hbWU6IHBvcy5uYW1lLCAgICAgICAgICBwYXJ0X25hbWU6IG51bGwsICAgICAgICB9OyAgICAgIH0gICAgfSAgICAgICAgaWYgKCFzdHVkZW50KSByZXR1cm47ICAgIGNvbnN0IGFjdGl2ZVBvc2l0aW9ucyA9ICAgICAgc2VsZWN0ZWRTdWJwYXJ0SWQgJiYgc3VicGFydHMubGVuZ3RoID4gMCAgICAgICAgPyBzdWJwYXJ0UG9zaXRpb25zW3NlbGVjdGVkU3VicGFydElkXSB8fCBbXSAgICAgICAgOiBwb3NpdGlvbnM7ICAgIC8vIEFsd2F5cyByZW1vdmUgb2xkIHBvc2l0aW9uIGZpcnN0ICh3aGV0aGVyIGZyb20gcm9zdGVyIG9yIGdyaWQpICAgIGNvbnN0IGZpbHRlcmVkID0gYWN0aXZlUG9zaXRpb25zLmZpbHRlcigocCkgPT4gcC5zdHVkZW50X2lkICE9PSBkcmFnZ2VkU3R1ZGVudCk7ICAgIC8vIEFkZCBhdCBuZXcgcG9zaXRpb24gICAgY29uc3QgbmV3UG9zaXRpb25zID0gWyAgICAgIC4uLmZpbHRlcmVkLCAgICAgIHsgICAgICAgIHN0dWRlbnRfaWQ6IGRyYWdnZWRTdHVkZW50LCAgICAgICAgbmFtZTogc3R1ZGVudC5uYW1lLCAgICAgICAgeDogdG9Mb2dpY2FsWCh4KSwgICAgICAgIHk6IHRvTG9naWNhbFkoeSksICAgICAgfSwgICAgXTsgICAgaWYgKHNlbGVjdGVkU3VicGFydElkICYmIHN1YnBhcnRzLmxlbmd0aCA+IDApIHsgICAgICBzZXRTdWJwYXJ0UG9zaXRpb25zKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBbc2VsZWN0ZWRTdWJwYXJ0SWRdOiBuZXdQb3NpdGlvbnMgfSkpOyAgICAgIGF3YWl0IGFkZE1pc3NpbmdBc3NpZ25lZEZyb21Qb3NpdGlvbnMoICAgICAgICBuZXdQb3NpdGlvbnMsICAgICAgICBzdWJwYXJ0T3JkZXJbc2VsZWN0ZWRTdWJwYXJ0SWRdIHx8IFtdICAgICAgKTsgICAgfSBlbHNlIHsgICAgICBzZXRQb3NpdGlvbnMobmV3UG9zaXRpb25zKTsgICAgfSAgICBoYXNDaGFuZ2VzUmVmLmN1cnJlbnQgPSB0cnVlOyAgICBzZXREcmFnZ2VkU3R1ZGVudChudWxsKTsgICAgc2V0RHJhZ2dlZEZyb21HcmlkKGZhbHNlKTsgIH07ICBjb25zdCByZW1vdmVGcm9tU3RhZ2UgPSAoc3R1ZGVudElkOiBzdHJpbmcpID0+IHsgICAgY29uc3QgcGVyc2lzdFBvc2l0aW9ucyA9IGFzeW5jIChuZXh0UG9zaXRpb25zOiBQb3NpdGlvbkVudHJ5W10pID0+IHsgICAgICB0cnkgeyAgICAgICAgaWYgKHNlbGVjdGVkU3VicGFydElkICYmIHN1YnBhcnRzLmxlbmd0aCA+IDApIHsgICAgICAgICAgYXdhaXQgZmV0Y2goXCIvYXBpL3N1YnBhcnQtcG9zaXRpb25zXCIsIHsgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLCAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7ICAgICAgICAgICAgICBzdWJwYXJ0X2lkOiBzZWxlY3RlZFN1YnBhcnRJZCwgICAgICAgICAgICAgIHBvc2l0aW9uczogbmV4dFBvc2l0aW9ucy5tYXAoKHApID0+ICh7ICAgICAgICAgICAgICAgIHN1YnBhcnRfaWQ6IHNlbGVjdGVkU3VicGFydElkLCAgICAgICAgICAgICAgICBzdHVkZW50X2lkOiBwLnN0dWRlbnRfaWQsICAgICAgICAgICAgICAgIHg6IHAueCwgICAgICAgICAgICAgICAgeTogcC55LCAgICAgICAgICAgICAgfSkpLCAgICAgICAgICAgIH0pLCAgICAgICAgICB9KTsgICAgICAgIH0gZWxzZSB7ICAgICAgICAgIGF3YWl0IG9uU2F2ZVBvc2l0aW9ucyhuZXh0UG9zaXRpb25zKTsgICAgICAgIH0gICAgICAgIGhhc0NoYW5nZXNSZWYuY3VycmVudCA9IGZhbHNlOyAgICAgICAgc2V0TGFzdFNhdmVkVGltZShEYXRlLm5vdygpKTsgICAgICB9IGNhdGNoIChlcnIpIHsgICAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBzYXZlIHBvc2l0aW9uc1wiKTsgICAgICAgIGhhc0NoYW5nZXNSZWYuY3VycmVudCA9IHRydWU7ICAgICAgfSAgICB9OyAgICBpZiAoc2VsZWN0ZWRTdWJwYXJ0SWQgJiYgc3VicGFydHMubGVuZ3RoID4gMCkgeyAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdWJwYXJ0UG9zaXRpb25zW3NlbGVjdGVkU3VicGFydElkXSB8fCBbXTsgICAgICBjb25zdCBuZXh0UG9zaXRpb25zID0gY3VycmVudC5maWx0ZXIoKHApID0+IHAuc3R1ZGVudF9pZCAhPT0gc3R1ZGVudElkKTsgICAgICBzZXRTdWJwYXJ0UG9zaXRpb25zKChwcmV2KSA9PiAoeyAgICAgICAgLi4ucHJldiwgICAgICAgIFtzZWxlY3RlZFN1YnBhcnRJZF06IG5leHRQb3NpdGlvbnMsICAgICAgfSkpOyAgICAgIHBlcnNpc3RQb3NpdGlvbnMobmV4dFBvc2l0aW9ucyk7ICAgIH0gZWxzZSB7ICAgICAgY29uc3QgbmV4dFBvc2l0aW9ucyA9IHBvc2l0aW9ucy5maWx0ZXIoKHApID0+IHAuc3R1ZGVudF9pZCAhPT0gc3R1ZGVudElkKTsgICAgICBzZXRQb3NpdGlvbnMobmV4dFBvc2l0aW9ucyk7ICAgICAgcGVyc2lzdFBvc2l0aW9ucyhuZXh0UG9zaXRpb25zKTsgICAgfSAgICBoYXNDaGFuZ2VzUmVmLmN1cnJlbnQgPSB0cnVlOyAgfTsgIGNvbnN0IHJlc2V0UG9zaXRpb25zID0gKCkgPT4geyAgICBpZiAoc2VsZWN0ZWRTdWJwYXJ0SWQgJiYgc3VicGFydHMubGVuZ3RoID4gMCkgeyAgICAgIHNldFN1YnBhcnRQb3NpdGlvbnMoKHByZXYpID0+ICh7IC4uLnByZXYsIFtzZWxlY3RlZFN1YnBhcnRJZF06IFtdIH0pKTsgICAgfSBlbHNlIHsgICAgICBzZXRQb3NpdGlvbnMoW10pOyAgICB9ICAgIGhhc0NoYW5nZXNSZWYuY3VycmVudCA9IHRydWU7ICB9OyAgY29uc3QgaGFuZGxlU2F2ZSA9IGFzeW5jICgpID0+IHsgICAgdHJ5IHsgICAgICBzZXRTYXZpbmcodHJ1ZSk7ICAgICAgLy8gU2F2ZSBwb3NpdGlvbnMgICAgaWYgKHNlbGVjdGVkU3VicGFydElkICYmIHN1YnBhcnRzLmxlbmd0aCA+IDApIHsgICAgICAgIGNvbnN0IHBheWxvYWQgPSAoc3VicGFydFBvc2l0aW9uc1tzZWxlY3RlZFN1YnBhcnRJZF0gfHwgW10pLm1hcCgocCkgPT4gKHsgICAgICAgICAgc3VicGFydF9pZDogc2VsZWN0ZWRTdWJwYXJ0SWQsICAgICAgICAgIHN0dWRlbnRfaWQ6IHAuc3R1ZGVudF9pZCwgICAgICAgICAgeDogcC54LCAgICAgICAgICB5OiBwLnksICAgICAgICB9KSk7ICAgICAgICBhd2FpdCBmZXRjaChcIi9hcGkvc3VicGFydC1wb3NpdGlvbnNcIiwgeyAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLCAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgICAgICAgICAgICBzdWJwYXJ0X2lkOiBzZWxlY3RlZFN1YnBhcnRJZCwgICAgICAgICAgICBwb3NpdGlvbnM6IHBheWxvYWQsICAgICAgICAgIH0pLCAgICAgICAgfSk7ICAgICAgfSBlbHNlIHsgICAgICAgIGF3YWl0IG9uU2F2ZVBvc2l0aW9ucyhwb3NpdGlvbnMpOyAgICAgIH0gICAgICAgICAgICAvLyBTYXZlIHN0YWdlIG9yaWVudGF0aW9uIGF0IHBlcmZvcm1hbmNlIGxldmVsICAgICAgYXdhaXQgZmV0Y2goYC9hcGkvcGVyZm9ybWFuY2VzLyR7cGVyZm9ybWFuY2VJZH1gLCB7ICAgICAgICBtZXRob2Q6IFwiUFVUXCIsICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHN0YWdlX29yaWVudGF0aW9uOiBmcm9udERpcmVjdGlvbiB9KSwgICAgICB9KTsgICAgICAgICAgICBzZXRFcnJvcihudWxsKTsgICAgfSBjYXRjaCAoZXJyKSB7ICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFwiRmFpbGVkIHRvIHNhdmUgcG9zaXRpb25zXCIpOyAgICB9IGZpbmFsbHkgeyAgICAgIHNldFNhdmluZyhmYWxzZSk7ICAgIH0gIH07ICBjb25zdCBwZXJzaXN0T3JkZXIgPSB1c2VDYWxsYmFjayhhc3luYyAoaXRlbXM6IEFycmF5PHsgaWQ6IHN0cmluZzsgc3R1ZGVudF9pZDogc3RyaW5nOyBzdHVkZW50X25hbWU6IHN0cmluZyB9PikgPT4geyAgICBpZiAoIXNlbGVjdGVkU3VicGFydElkKSByZXR1cm47ICAgIHNldFN1YnBhcnRPcmRlcigocHJldikgPT4gKHsgLi4ucHJldiwgW3NlbGVjdGVkU3VicGFydElkXTogaXRlbXMgfSkpOyAgICBhd2FpdCBmZXRjaChcIi9hcGkvc3VicGFydC1vcmRlclwiLCB7ICAgICAgbWV0aG9kOiBcIlBPU1RcIiwgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoICAgICAgICBpdGVtcy5tYXAoKGl0ZW0sIGlkeCkgPT4gKHsgICAgICAgICAgc3VicGFydF9pZDogc2VsZWN0ZWRTdWJwYXJ0SWQsICAgICAgICAgIHN0dWRlbnRfaWQ6IGl0ZW0uc3R1ZGVudF9pZCwgICAgICAgICAgb3JkZXI6IGlkeCArIDEsICAgICAgICB9KSkgICAgICApLCAgICB9KTsgIH0sIFtzZWxlY3RlZFN1YnBhcnRJZF0pOyAgY29uc3QgYWRkVG9PcmRlciA9IGFzeW5jIChzdHVkZW50SWQ6IHN0cmluZywgc3R1ZGVudE5hbWU6IHN0cmluZykgPT4geyAgICBpZiAoIXNlbGVjdGVkU3VicGFydElkKSByZXR1cm47ICAgIGNvbnN0IG5leHQgPSBbLi4ub3JkZXJJdGVtcywgeyBpZDogYHRlbXAtJHtEYXRlLm5vdygpfWAsIHN0dWRlbnRfaWQ6IHN0dWRlbnRJZCwgc3R1ZGVudF9uYW1lOiBzdHVkZW50TmFtZSB9XTsgICAgYXdhaXQgcGVyc2lzdE9yZGVyKG5leHQpOyAgfTsgIGNvbnN0IGFkZE1pc3NpbmdBc3NpZ25lZEZyb21Qb3NpdGlvbnMgPSB1c2VDYWxsYmFjayhhc3luYyAoICAgIHBvc2l0aW9uc0xpc3Q6IFBvc2l0aW9uRW50cnlbXSwgICAgY3VycmVudEl0ZW1zOiBBcnJheTx7IGlkOiBzdHJpbmc7IHN0dWRlbnRfaWQ6IHN0cmluZzsgc3R1ZGVudF9uYW1lOiBzdHJpbmcgfT4gICkgPT4geyAgICBpZiAoIXNlbGVjdGVkU3VicGFydElkKSByZXR1cm47ICAgIGNvbnN0IGV4aXN0aW5nID0gbmV3IFNldChjdXJyZW50SXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLnN0dWRlbnRfaWQpKTsgICAgY29uc3QgbWlzc2luZyA9IHBvc2l0aW9uc0xpc3QgICAgICAuZmlsdGVyKChwb3MpID0+IHBvcy5zdHVkZW50X2lkICYmICFleGlzdGluZy5oYXMocG9zLnN0dWRlbnRfaWQpKSAgICAgIC5tYXAoKHBvcykgPT4gKHsgICAgICAgIGlkOiBgdGVtcC0ke0RhdGUubm93KCl9LSR7cG9zLnN0dWRlbnRfaWR9YCwgICAgICAgIHN0dWRlbnRfaWQ6IHBvcy5zdHVkZW50X2lkLCAgICAgICAgc3R1ZGVudF9uYW1lOiBwb3MubmFtZSwgICAgICB9KSk7ICAgIGlmIChtaXNzaW5nLmxlbmd0aCA9PT0gMCkgcmV0dXJuOyAgICBjb25zdCBuZXh0ID0gWy4uLmN1cnJlbnRJdGVtcywgLi4ubWlzc2luZ107ICAgIGF3YWl0IHBlcnNpc3RPcmRlcihuZXh0KTsgIH0sIFtwZXJzaXN0T3JkZXIsIHNlbGVjdGVkU3VicGFydElkXSk7ICB1c2VFZmZlY3QoKCkgPT4geyAgICBpZiAoIXNlbGVjdGVkU3VicGFydElkKSByZXR1cm47ICAgIGNvbnN0IHBvc2l0aW9uc0xpc3QgPSBzdWJwYXJ0UG9zaXRpb25zW3NlbGVjdGVkU3VicGFydElkXSB8fCBbXTsgICAgY29uc3QgaXRlbXMgPSBzdWJwYXJ0T3JkZXJbc2VsZWN0ZWRTdWJwYXJ0SWRdIHx8IFtdOyAgICBpZiAocG9zaXRpb25zTGlzdC5sZW5ndGggPT09IDApIHJldHVybjsgICAgYWRkTWlzc2luZ0Fzc2lnbmVkRnJvbVBvc2l0aW9ucyhwb3NpdGlvbnNMaXN0LCBpdGVtcyk7ICB9LCBbc2VsZWN0ZWRTdWJwYXJ0SWQsIHN1YnBhcnRQb3NpdGlvbnMsIHN1YnBhcnRPcmRlciwgYWRkTWlzc2luZ0Fzc2lnbmVkRnJvbVBvc2l0aW9uc10pOyAgY29uc3QgbG9hZFNvdXJjZVBvc2l0aW9ucyA9IGFzeW5jICgpID0+IHsgICAgaWYgKCFzZWxlY3RlZFNvdXJjZUtleSkgcmV0dXJuIFtdOyAgICBjb25zdCBbdHlwZSwgaWRdID0gc2VsZWN0ZWRTb3VyY2VLZXkuc3BsaXQoXCI6XCIpOyAgICBpZiAoIWlkKSByZXR1cm4gW107ICAgIGNvbnN0IHVybCA9ICAgICAgdHlwZSA9PT0gXCJzdWJwYXJ0XCIgICAgICAgID8gYC9hcGkvc3VicGFydC1wb3NpdGlvbnM/c3VicGFydElkPSR7aWR9YCAgICAgICAgOiBgL2FwaS9zdGFnZS1wb3NpdGlvbnM/cGFydElkPSR7aWR9YDsgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsKTsgICAgaWYgKCFyZXMub2spIHsgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTsgICAgICB0aHJvdyBuZXcgRXJyb3IodGV4dCB8fCBcIkZhaWxlZCB0byBmZXRjaCBzb3VyY2UgcG9zaXRpb25zXCIpOyAgICB9ICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpOyAgICByZXR1cm4gKGRhdGEgfHwgW10pLm1hcCgocDogYW55KSA9PiAoeyAgICAgIHN0dWRlbnRfaWQ6IHAuc3R1ZGVudF9pZCB8fCBcIlwiLCAgICAgIG5hbWU6IHAuc3R1ZGVudF9uYW1lIHx8IFwiVW5rbm93blwiLCAgICAgIHg6IHAueCwgICAgICB5OiBwLnksICAgIH0pKSBhcyBQb3NpdGlvbkVudHJ5W107ICB9OyAgY29uc3QgYXBwbHlRdWlja1Bvc2l0aW9ucyA9IGFzeW5jICgpID0+IHsgICAgaWYgKCFzZWxlY3RlZFNvdXJjZUtleSkgcmV0dXJuOyAgICBzZXRBcHBseWluZ1F1aWNrKHRydWUpOyAgICB0cnkgeyAgICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9ucyA9IGF3YWl0IGxvYWRTb3VyY2VQb3NpdGlvbnMoKTsgICAgICBjb25zdCBtYXBwZWQgPSBzb3VyY2VQb3NpdGlvbnMubWFwKChwKSA9PiB7ICAgICAgICBjb25zdCBmbGlwcGVkWCA9IGZsaXBIb3Jpem9udGFsID8gR1JJRF9DT0xTIC0gMSAtIHAueCA6IHAueDsgICAgICAgIHJldHVybiB7ICAgICAgICAgIC4uLnAsICAgICAgICAgIHg6IGNsYW1wVG9HcmlkKGZsaXBwZWRYLCBHUklEX0NPTFMgLSAxKSwgICAgICAgICAgeTogY2xhbXBUb0dyaWQocC55LCBHUklEX1JPV1MgLSAxKSwgICAgICAgIH07ICAgICAgfSk7ICAgICAgaWYgKHNlbGVjdGVkU3VicGFydElkICYmIHN1YnBhcnRzLmxlbmd0aCA+IDApIHsgICAgICAgIHNldFN1YnBhcnRQb3NpdGlvbnMoKHByZXYpID0+ICh7IC4uLnByZXYsIFtzZWxlY3RlZFN1YnBhcnRJZF06IG1hcHBlZCB9KSk7ICAgICAgICBhd2FpdCBhZGRNaXNzaW5nQXNzaWduZWRGcm9tUG9zaXRpb25zKCAgICAgICAgICBtYXBwZWQsICAgICAgICAgIHN1YnBhcnRPcmRlcltzZWxlY3RlZFN1YnBhcnRJZF0gfHwgW10gICAgICAgICk7ICAgICAgICBhd2FpdCBmZXRjaChcIi9hcGkvc3VicGFydC1wb3NpdGlvbnNcIiwgeyAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLCAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgICAgICAgICAgICBzdWJwYXJ0X2lkOiBzZWxlY3RlZFN1YnBhcnRJZCwgICAgICAgICAgICBwb3NpdGlvbnM6IG1hcHBlZC5tYXAoKHApID0+ICh7ICAgICAgICAgICAgICBzdWJwYXJ0X2lkOiBzZWxlY3RlZFN1YnBhcnRJZCwgICAgICAgICAgICAgIHN0dWRlbnRfaWQ6IHAuc3R1ZGVudF9pZCwgICAgICAgICAgICAgIHg6IHAueCwgICAgICAgICAgICAgIHk6IHAueSwgICAgICAgICAgICB9KSksICAgICAgICAgIH0pLCAgICAgICAgfSk7ICAgICAgfSBlbHNlIHsgICAgICAgIHNldFBvc2l0aW9ucyhtYXBwZWQpOyAgICAgICAgYXdhaXQgb25TYXZlUG9zaXRpb25zKG1hcHBlZCk7ICAgICAgfSAgICAgIGhhc0NoYW5nZXNSZWYuY3VycmVudCA9IGZhbHNlOyAgICAgIHNldExhc3RTYXZlZFRpbWUoRGF0ZS5ub3coKSk7ICAgICAgc2V0RXJyb3IobnVsbCk7ICAgIH0gY2F0Y2ggKGVycikgeyAgICAgIHNldEVycm9yKGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkZhaWxlZCB0byBhcHBseSBwb3NpdGlvbnNcIik7ICAgIH0gZmluYWxseSB7ICAgICAgc2V0QXBwbHlpbmdRdWljayhmYWxzZSk7ICAgIH0gIH07ICBjb25zdCBhY3RpdmVTdWJwYXJ0ID0gc3VicGFydHMuZmluZCgocykgPT4gcy5pZCA9PT0gc2VsZWN0ZWRTdWJwYXJ0SWQpOyAgY29uc3Qgc3VicGFydE1vZGUgPSBhY3RpdmVTdWJwYXJ0Py5tb2RlIHx8IFwicG9zaXRpb25cIjsgIGNvbnN0IGNhblBvc2l0aW9uID0gc3VicGFydHMubGVuZ3RoID09PSAwIHx8IHN1YnBhcnRNb2RlICE9PSBcIm9yZGVyXCI7ICBjb25zdCBjYW5PcmRlciA9IHN1YnBhcnRzLmxlbmd0aCA+IDA7ICBjb25zdCBvcmRlckl0ZW1zID0gc2VsZWN0ZWRTdWJwYXJ0SWQgPyBzdWJwYXJ0T3JkZXJbc2VsZWN0ZWRTdWJwYXJ0SWRdIHx8IFtdIDogW107ICBjb25zdCBhY3RpdmVQb3NpdGlvbnMgPSAgICBzZWxlY3RlZFN1YnBhcnRJZCAmJiBzdWJwYXJ0cy5sZW5ndGggPiAwICAgICAgPyBzdWJwYXJ0UG9zaXRpb25zW3NlbGVjdGVkU3VicGFydElkXSB8fCBbXSAgICAgIDogcG9zaXRpb25zOyAgY29uc3QgcG9zaXRpb25lZFN0dWRlbnRzID0gbmV3IFNldChhY3RpdmVQb3NpdGlvbnMubWFwKChwKSA9PiBwLnN0dWRlbnRfaWQpKTsgIGNvbnN0IGF2YWlsYWJsZVN0dWRlbnRzID0gcm9zdGVyOyAgLy8gR2VuZXJhdGUgbGVnZW5kIHdpdGggaW5pdGlhbHMgKGRlZHVwbGljYXRlZCkgIGNvbnN0IHVuaXF1ZVN0dWRlbnRzID0gbmV3IE1hcDxzdHJpbmcsIHR5cGVvZiBwb3NpdGlvbnNbMF0+KCk7ICBhY3RpdmVQb3NpdGlvbnMuZm9yRWFjaCgocG9zKSA9PiB7ICAgIGlmICghdW5pcXVlU3R1ZGVudHMuaGFzKHBvcy5zdHVkZW50X2lkKSkgeyAgICAgIHVuaXF1ZVN0dWRlbnRzLnNldChwb3Muc3R1ZGVudF9pZCwgcG9zKTsgICAgfSAgfSk7ICAgIGNvbnN0IGxlZ2VuZERhdGEgPSBBcnJheS5mcm9tKHVuaXF1ZVN0dWRlbnRzLnZhbHVlcygpKS5tYXAoKHBvcykgPT4gKHsgICAgc3R1ZGVudF9pZDogcG9zLnN0dWRlbnRfaWQsICAgIG5hbWU6IHBvcy5uYW1lLCAgICBpbml0aWFsczogZ2VuZXJhdGVJbml0aWFscyhwb3MubmFtZSwgQXJyYXkuZnJvbSh1bmlxdWVTdHVkZW50cy52YWx1ZXMoKSkubWFwKChwKSA9PiBwLm5hbWUpKSwgIH0pKTsgIGlmIChsb2FkaW5nKSB7ICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHB5LThcIj5Mb2FkaW5nLi4uPC9kaXY+OyAgfSAgcmV0dXJuICggICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj4gICAgICB7ZXJyb3IgJiYgKCAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1yZWQtMTAwIGJvcmRlciBib3JkZXItcmVkLTQwMCB0ZXh0LXJlZC03MDAgcHgtNCBweS0zIHJvdW5kZWRcIj4gICAgICAgICAge2Vycm9yfSAgICAgICAgPC9kaXY+ICAgICAgKX0gICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbGc6Z3JpZC1jb2xzLVsyMjBweF8xZnJdIGdhcC02XCI+ICAgICAgICB7LyogUm9zdGVyIExpc3QgKi99ICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktNTAgcC00IHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci1ncmF5LTIwMFwiPiAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZCB0ZXh0LWdyYXktOTAwIG1iLTJcIj4gICAgICAgICAgICBTdHVkZW50cyAoe2F2YWlsYWJsZVN0dWRlbnRzLmxlbmd0aH0pICAgICAgICAgIDwvaDM+ICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtWzExcHhdIHRleHQtZ3JheS01MDAgbWItM1wiPiAgICAgICAgICAgIFBvc2l0aW9uZWQgc3R1ZGVudHMgc3RheSBoZXJlIHNvIHlvdSBjYW4gYXNzaWduIHRoZW0gdG8gc3VicGFydHMuICAgICAgICAgIDwvcD4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTIgbWF4LWgtOTYgb3ZlcmZsb3cteS1hdXRvXCI+ICAgICAgICAgICAge2F2YWlsYWJsZVN0dWRlbnRzLmxlbmd0aCA9PT0gMCA/ICggICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDAgdGV4dC1zbVwiPk5vIHN0dWRlbnRzIHlldC48L3A+ICAgICAgICAgICAgKSA6ICggICAgICAgICAgICAgIGF2YWlsYWJsZVN0dWRlbnRzLm1hcCgoc3R1ZGVudCkgPT4geyAgICAgICAgICAgICAgICBjb25zdCBpc1Bvc2l0aW9uZWQgPSBwb3NpdGlvbmVkU3R1ZGVudHMuaGFzKHN0dWRlbnQuc3R1ZGVudF9pZCk7ICAgICAgICAgICAgICAgIHJldHVybiAoICAgICAgICAgICAgICAgICAgPGRpdiAgICAgICAgICAgICAgICAgICAga2V5PXtzdHVkZW50LnN0dWRlbnRfaWR9ICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGUgICAgICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0PXsoKSA9PiBoYW5kbGVEcmFnU3RhcnQoc3R1ZGVudC5zdHVkZW50X2lkLCBmYWxzZSl9ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BwLTMgcm91bmRlZCBib3JkZXIgY3Vyc29yLW1vdmUgaG92ZXI6c2hhZG93LW1kIHRyYW5zaXRpb24tYWxsICR7ICAgICAgICAgICAgICAgICAgICAgIGlzUG9zaXRpb25lZCAgICAgICAgICAgICAgICAgICAgICAgID8gXCJiZy1lbWVyYWxkLTUwIGJvcmRlci1lbWVyYWxkLTIwMCBob3Zlcjpib3JkZXItZW1lcmFsZC0zMDBcIiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJiZy13aGl0ZSBib3JkZXItYmx1ZS0yMDAgaG92ZXI6Ym9yZGVyLWJsdWUtNDAwXCIgICAgICAgICAgICAgICAgICAgIH1gfSAgICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGdhcC0yXCI+ICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtc20gdGV4dC1ncmF5LTkwMFwiPiAgICAgICAgICAgICAgICAgICAgICAgIHtzdHVkZW50Lm5hbWV9ICAgICAgICAgICAgICAgICAgICAgIDwvcD4gICAgICAgICAgICAgICAgICAgICAge2lzUG9zaXRpb25lZCAmJiAoICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1bMTBweF0gcHgtMiBweS0wLjUgcm91bmRlZCBiZy1lbWVyYWxkLTEwMCB0ZXh0LWVtZXJhbGQtNzAwIGZvbnQtc2VtaWJvbGRcIj4gICAgICAgICAgICAgICAgICAgICAgICAgIFBvc2l0aW9uZWQgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgICAgICAgICAgICl9ICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICAgIHtzdHVkZW50LnBhcnRfbmFtZSAmJiAoICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTYwMFwiPntzdHVkZW50LnBhcnRfbmFtZX08L3A+ICAgICAgICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICApOyAgICAgICAgICAgICAgfSkgICAgICAgICAgICApfSAgICAgICAgICA8L2Rpdj4gICAgICAgICAge2Nhbk9yZGVyICYmIHNlbGVjdGVkU3VicGFydElkICYmICggICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgYm9yZGVyLXQgYm9yZGVyLWdyYXktMjAwIHB0LTRcIj4gICAgICAgICAgICAgIDxoNCBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwIG1iLTIgdGV4dC1zbVwiPiAgICAgICAgICAgICAgICBBc3NpZ25lZCBTdHVkZW50cyAgICAgICAgICAgICAgPC9oND4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtWzExcHhdIHRleHQtZ3JheS01MDAgbWItMlwiPiAgICAgICAgICAgICAgICBEcmFnIHN0dWRlbnRzIGhlcmUgdG8gYXNzaWduIHRoZW0gdG8gdGhpcyBzdWJwYXJ0LiAgICAgICAgICAgICAgPC9wPiAgICAgICAgICAgICAgPGRpdiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTIgcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyYXktMjAwXCIgICAgICAgICAgICAgICAgb25EcmFnT3Zlcj17KGUpID0+IGUucHJldmVudERlZmF1bHQoKX0gICAgICAgICAgICAgICAgb25Ecm9wPXthc3luYyAoKSA9PiB7ICAgICAgICAgICAgICAgICAgaWYgKCFkcmFnZ2VkU3R1ZGVudCkgcmV0dXJuOyAgICAgICAgICAgICAgICAgIGNvbnN0IHN0dWRlbnQgPSByb3N0ZXIuZmluZCgocykgPT4gcy5zdHVkZW50X2lkID09PSBkcmFnZ2VkU3R1ZGVudCk7ICAgICAgICAgICAgICAgICAgaWYgKCFzdHVkZW50KSByZXR1cm47ICAgICAgICAgICAgICAgICAgYXdhaXQgYWRkVG9PcmRlcihzdHVkZW50LnN0dWRlbnRfaWQsIHN0dWRlbnQubmFtZSk7ICAgICAgICAgICAgICAgIH19ICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+ICAgICAgICAgICAgICAgICAge29yZGVySXRlbXMubGVuZ3RoID09PSAwID8gKCAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDAgYm9yZGVyIGJvcmRlci1kYXNoZWQgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQgcC0yIHRleHQtY2VudGVyXCI+ICAgICAgICAgICAgICAgICAgICAgIERyb3Agc3R1ZGVudHMgaGVyZSAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgKSA6ICggICAgICAgICAgICAgICAgICAgIG9yZGVySXRlbXMubWFwKChpdGVtLCBpZHgpID0+ICggICAgICAgICAgICAgICAgICAgICAgPGRpdiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aXRlbS5pZH0gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2FibGUgICAgICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdGFydD17KCkgPT4gc2V0RHJhZ2dpbmdPcmRlcklkKGl0ZW0uaWQpfSAgICAgICAgICAgICAgICAgICAgICAgIG9uRHJhZ092ZXI9eyhlKSA9PiBlLnByZXZlbnREZWZhdWx0KCl9ICAgICAgICAgICAgICAgICAgICAgICAgb25Ecm9wPXthc3luYyAoKSA9PiB7ICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRyYWdnaW5nT3JkZXJJZCkgcmV0dXJuOyAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbUlkeCA9IG9yZGVySXRlbXMuZmluZEluZGV4KChpKSA9PiBpLmlkID09PSBkcmFnZ2luZ09yZGVySWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9JZHggPSBvcmRlckl0ZW1zLmZpbmRJbmRleCgoaSkgPT4gaS5pZCA9PT0gaXRlbS5pZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbUlkeCA8IDAgfHwgdG9JZHggPCAwKSByZXR1cm47ICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gWy4uLm9yZGVySXRlbXNdOyAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW21vdmVkXSA9IG5leHQuc3BsaWNlKGZyb21JZHgsIDEpOyAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5zcGxpY2UodG9JZHgsIDAsIG1vdmVkKTsgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHBlcnNpc3RPcmRlcihuZXh0KTsgICAgICAgICAgICAgICAgICAgICAgICAgIHNldERyYWdnaW5nT3JkZXJJZChudWxsKTsgICAgICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBiZy1ncmF5LTUwIGJvcmRlciBib3JkZXItZ3JheS0yMDAgcm91bmRlZCBweC0yIHB5LTFcIiAgICAgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS05MDBcIj4gICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS01MDAgbXItMVwiPntpZHggKyAxfS48L3NwYW4+ICAgICAgICAgICAgICAgICAgICAgICAgICB7aXRlbS5zdHVkZW50X25hbWV9ICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YXN5bmMgKCkgPT4geyAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gb3JkZXJJdGVtcy5maWx0ZXIoKGkpID0+IGkuaWQgIT09IGl0ZW0uaWQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBwZXJzaXN0T3JkZXIobmV4dCk7ICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1bMTBweF0gdGV4dC1yZWQtNjAwIGhvdmVyOnRleHQtcmVkLTgwMFwiICAgICAgICAgICAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgICAgICAgICAgICAgUmVtb3ZlICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgKSkgICAgICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICApfSAgICAgICAgPC9kaXY+ICAgICAgICB7LyogU3RhZ2UgR3JpZCAqL30gICAgICAgIDxkaXY+ICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS00XCI+ICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBpdGVtcy1zdGFydCBqdXN0aWZ5LWJldHdlZW4gZ2FwLTMgbWItNFwiPiAgICAgICAgICAgICAgPGRpdj4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPiAgICAgICAgICAgICAgICAgIDxBcHBMb2dvIHNpemU9ezI0fSBjbGFzc05hbWU9XCJib3JkZXIgYm9yZGVyLWdyYXktMjAwIGJnLXdoaXRlIHRleHQtZ3JheS00MDBcIiAvPiAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtZ3JheS05MDBcIj5TdGFnZSBMYXlvdXQ8L2gzPiAgICAgICAgICAgICAgICAgIHtlZGl0aW5nUGFydE5hbWUgPyAoICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+ICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17cGFydE5hbWVEcmFmdH0gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFBhcnROYW1lRHJhZnQoZS50YXJnZXQudmFsdWUpfSAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWQgdGV4dC1zbVwiICAgICAgICAgICAgICAgICAgICAgIC8+ICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXthc3luYyAoKSA9PiB7ICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRJZCkgcmV0dXJuOyAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE5hbWUgPSBwYXJ0TmFtZURyYWZ0LnRyaW0oKTsgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV4dE5hbWUpIHJldHVybjsgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFBhcnROYW1lU2F2aW5nKHRydWUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvcGFydHMvJHtwYXJ0SWR9YCwgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBuYW1lOiBuZXh0TmFtZSB9KSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLm9rKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIHBhcnQgbmFtZVwiKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWRpdGluZ1BhcnROYW1lKGZhbHNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnIubWVzc2FnZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkZhaWxlZCB0byB1cGRhdGUgcGFydCBuYW1lXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTsgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFBhcnROYW1lU2F2aW5nKGZhbHNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtwYXJ0TmFtZVNhdmluZ30gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctZ3JlZW4tNjAwIHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXhzIGRpc2FibGVkOmJnLWdyYXktNDAwXCIgICAgICAgICAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgICAgICAgICAgIHtwYXJ0TmFtZVNhdmluZyA/IFwiU2F2aW5nLi4uXCIgOiBcIlNhdmVcIn0gICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7ICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFZGl0aW5nUGFydE5hbWUoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UGFydE5hbWVEcmFmdChwYXJ0TmFtZSB8fCBcIlwiKTsgICAgICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmF5LTMwMCB0ZXh0LWdyYXktODAwIHJvdW5kZWQgdGV4dC14c1wiICAgICAgICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICAgICAgICBDYW5jZWwgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICApIDogKCAgICAgICAgICAgICAgICAgICAgPD4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktNzAwXCI+ICAgICAgICAgICAgICAgICAgICAgICAge3BhcnROYW1lID8gYC0gJHtwYXJ0TmFtZX1gIDogXCJcIn0gICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RWRpdGluZ1BhcnROYW1lKHRydWUpfSAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ibHVlLTYwMCBob3Zlcjp0ZXh0LWJsdWUtODAwXCIgICAgICAgICAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgICAgICAgICAgIEVkaXQgbmFtZSAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4gICAgICAgICAgICAgICAgICAgIDwvPiAgICAgICAgICAgICAgICAgICl9ICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTJcIj4gICAgICAgICAgICAgICAgICB7ZWRpdGluZ1BhcnROb3RlcyA/ICggICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+ICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtwYXJ0Tm90ZXNEcmFmdH0gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFBhcnROb3Rlc0RyYWZ0KGUudGFyZ2V0LnZhbHVlKX0gICAgICAgICAgICAgICAgICAgICAgICByb3dzPXsyfSAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQWRkIHBhcnQgbm90ZXMuLi5cIiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBweC0yIHB5LTEgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkIHRleHQtc21cIiAgICAgICAgICAgICAgICAgICAgICAvPiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+ICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17YXN5bmMgKCkgPT4geyAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnRJZCkgcmV0dXJuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQYXJ0Tm90ZXNTYXZpbmcodHJ1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYC9hcGkvcGFydHMvJHtwYXJ0SWR9YCwgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBkZXNjcmlwdGlvbjogcGFydE5vdGVzRHJhZnQgfHwgbnVsbCB9KSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBwYXJ0IG5vdGVzXCIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEVkaXRpbmdQYXJ0Tm90ZXMoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyLm1lc3NhZ2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkZhaWxlZCB0byB1cGRhdGUgcGFydCBub3Rlc1wiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQYXJ0Tm90ZXNTYXZpbmcoZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3BhcnROb3Rlc1NhdmluZ30gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmVlbi02MDAgdGV4dC13aGl0ZSByb3VuZGVkIHRleHQteHMgZGlzYWJsZWQ6YmctZ3JheS00MDBcIiAgICAgICAgICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICAgICAgICAgIHtwYXJ0Tm90ZXNTYXZpbmcgPyBcIlNhdmluZy4uLlwiIDogXCJTYXZlIG5vdGVzXCJ9ICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4geyAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFZGl0aW5nUGFydE5vdGVzKGZhbHNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UGFydE5vdGVzRHJhZnQocGFydERlc2NyaXB0aW9uIHx8IFwiXCIpOyAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmF5LTMwMCB0ZXh0LWdyYXktODAwIHJvdW5kZWQgdGV4dC14c1wiICAgICAgICAgICAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FuY2VsICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgKSA6ICggICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1zdGFydCBnYXAtMlwiPiAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDBcIj4gICAgICAgICAgICAgICAgICAgICAgICB7cGFydERlc2NyaXB0aW9uID8gcGFydERlc2NyaXB0aW9uIDogXCJObyBub3RlcyB5ZXQuXCJ9ICAgICAgICAgICAgICAgICAgICAgIDwvcD4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEVkaXRpbmdQYXJ0Tm90ZXModHJ1ZSl9ICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWJsdWUtNjAwIGhvdmVyOnRleHQtYmx1ZS04MDBcIiAgICAgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICAgICAgRWRpdCBub3RlcyAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICl9ICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDAgbXQtMVwiPiAgICAgICAgICAgICAgICAgIEZyb250IG9mIHN0YWdlOiB7ZnJvbnREaXJlY3Rpb24gPT09IFwiYm90dG9tXCIgPyBcIkJvdHRvbVwiIDogXCJUb3BcIn0gICAgICAgICAgICAgICAgPC9wPiAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICB7c3VicGFydHMubGVuZ3RoID4gMCAmJiAoICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS02MDBcIj5TdWJwYXJ0PC9zcGFuPiAgICAgICAgICAgICAgICAgIDxzZWxlY3QgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtzZWxlY3RlZFN1YnBhcnRJZCB8fCBcIlwifSAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRTZWxlY3RlZFN1YnBhcnRJZChlLnRhcmdldC52YWx1ZSl9ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkIHRleHQteHNcIiAgICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5QYXJ0IHBvc2l0aW9uczwvb3B0aW9uPiAgICAgICAgICAgICAgICAgICAge3N1YnBhcnRzLm1hcCgoc3ViKSA9PiAoICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PXtzdWIuaWR9IHZhbHVlPXtzdWIuaWR9PiAgICAgICAgICAgICAgICAgICAgICAgIHtzdWIudGl0bGV9ICAgICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPiAgICAgICAgICAgICAgICAgICAgKSl9ICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+ICAgICAgICAgICAgICAgICAge2FjdGl2ZVN1YnBhcnQ/LmRlc2NyaXB0aW9uICYmICggICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtWzEwcHhdIHRleHQtZ3JheS01MDBcIj4gICAgICAgICAgICAgICAgICAgICAge2FjdGl2ZVN1YnBhcnQuZGVzY3JpcHRpb259ICAgICAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgICAgICAgKX0gICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWVuZCBnYXAtMlwiPiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zIHRleHQteHNcIj4gICAgICAgICAgICAgICAgICB7c2F2aW5nICYmICggICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtYmx1ZS02MDAgZm9udC1zZW1pYm9sZFwiPkF1dG8tc2F2aW5nLi4uPC9zcGFuPiAgICAgICAgICAgICAgICAgICl9ICAgICAgICAgICAgICAgICAgeyFzYXZpbmcgJiYgaGFzQ2hhbmdlc1JlZi5jdXJyZW50ICYmICggICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtb3JhbmdlLTYwMCBmb250LXNlbWlib2xkXCI+ICAgICAgICAgICAgICAgICAgICAgIFVuc2F2ZWQgY2hhbmdlcyAoYXV0by1zYXZlcyBpbiA2cykgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj4gICAgICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yXCI+ICAgICAgICAgICAgICAgICAgPHNlbGVjdCAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2Zyb250RGlyZWN0aW9ufSAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRGcm9udERpcmVjdGlvbihlLnRhcmdldC52YWx1ZSBhcyBGcm9udERpcmVjdGlvbil9ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTIgYm9yZGVyIGJvcmRlci1ncmF5LTMwMCByb3VuZGVkLWxnIHRleHQtc20gZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwXCIgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiYm90dG9tXCI+RnJvbnQgLSBCb3R0b208L29wdGlvbj4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJ0b3BcIj5Gcm9udCAtIFRvcDwvb3B0aW9uPiAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PiAgICAgICAgICAgICAgICAgIDxidXR0b24gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e3Jlc2V0UG9zaXRpb25zfSAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWdyYXktMzAwIHRleHQtZ3JheS05MDAgcm91bmRlZC1sZyBob3ZlcjpiZy1ncmF5LTQwMCBmb250LW1lZGl1bSB0ZXh0LXNtXCIgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICBSZXNldCBBbGwgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4gICAgICAgICAgICAgICAgICA8YnV0dG9uICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTYXZlfSAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3NhdmluZ30gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmVlbi02MDAgdGV4dC13aGl0ZSByb3VuZGVkLWxnIGhvdmVyOmJnLWdyZWVuLTcwMCBkaXNhYmxlZDpiZy1ncmF5LTQwMCBmb250LW1lZGl1bSB0ZXh0LXNtXCIgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICB7c2F2aW5nID8gXCJTYXZpbmcuLi5cIiA6IFwiU2F2ZSBQb3NpdGlvbnNcIn0gICAgICAgICAgICAgICAgICA8L2J1dHRvbj4gICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICB7LyogTGVnZW5kICovfSAgICAgICAgICAgIHthY3RpdmVQb3NpdGlvbnMubGVuZ3RoID4gMCAmJiAoICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWJsdWUtNTAgcC0zIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci1ibHVlLTIwMFwiPiAgICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMCBtYi0yIHRleHQtc21cIj5MZWdlbmQ8L2g0PiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgc206Z3JpZC1jb2xzLTMgbWQ6Z3JpZC1jb2xzLTQgZ2FwLTJcIj4gICAgICAgICAgICAgICAgICB7bGVnZW5kRGF0YS5tYXAoKGl0ZW0pID0+ICggICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtpdGVtLnN0dWRlbnRfaWR9IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHRleHQtc21cIj4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTYgaC02IGJnLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LXdoaXRlIHRleHQteHMgZm9udC1ib2xkXCI+ICAgICAgICAgICAgICAgICAgICAgICAge2l0ZW0uaW5pdGlhbHN9ICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNzAwIHRydW5jYXRlXCI+e2l0ZW0ubmFtZX08L3NwYW4+ICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgICApKX0gICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICApfSAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUgcC0zIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci1ncmF5LTIwMFwiPiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwIHRleHQtc20gbWItMlwiPlF1aWNrIFBvc2l0aW9uPC9kaXY+ICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbWQ6Z3JpZC1jb2xzLVsxZnJfYXV0b10gZ2FwLTIgaXRlbXMtY2VudGVyXCI+ICAgICAgICAgICAgICAgIDxzZWxlY3QgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VsZWN0ZWRTb3VyY2VLZXl9ICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRTZWxlY3RlZFNvdXJjZUtleShlLnRhcmdldC52YWx1ZSl9ICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMiBweS0xIGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZCB0ZXh0LXNtXCIgICAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIj5TZWxlY3QgYSBwYXJ0IG9yIHN1YnBhcnQuLi48L29wdGlvbj4gICAgICAgICAgICAgICAgICB7c291cmNlT3B0aW9ucy5tYXAoKG9wdCkgPT4gKCAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e29wdC5rZXl9IHZhbHVlPXtvcHQua2V5fT4gICAgICAgICAgICAgICAgICAgICAge29wdC5sYWJlbH0gICAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPiAgICAgICAgICAgICAgICAgICkpfSAgICAgICAgICAgICAgICA8L3NlbGVjdD4gICAgICAgICAgICAgICAgPGJ1dHRvbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2FwcGx5UXVpY2tQb3NpdGlvbnN9ICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFzZWxlY3RlZFNvdXJjZUtleSB8fCBhcHBseWluZ1F1aWNrfSAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTMgcHktMSBiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgdGV4dC1zbSBkaXNhYmxlZDpiZy1ncmF5LTQwMFwiICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICB7YXBwbHlpbmdRdWljayA/IFwiQXBwbHlpbmcuLi5cIiA6IFwiQXBwbHlcIn0gICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJtdC0yIGZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHRleHQteHMgdGV4dC1ncmF5LTcwMFwiPiAgICAgICAgICAgICAgICA8aW5wdXQgICAgICAgICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIiAgICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2ZsaXBIb3Jpem9udGFsfSAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0RmxpcEhvcml6b250YWwoZS50YXJnZXQuY2hlY2tlZCl9ICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC00IHctNFwiICAgICAgICAgICAgICAgIC8+ICAgICAgICAgICAgICAgIEhvcml6b250YWwgZmxpcCBiZWZvcmUgYXBwbHlpbmcgICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAge3N1YnBhcnRzLmxlbmd0aCA+IDAgJiYgKCAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS03MDAgZm9udC1tZWRpdW0gdGV4dC1jZW50ZXJcIj4gICAgICAgICAgICAgICAge2FjdGl2ZVN1YnBhcnQ/LnRpdGxlIHx8IFwiU3VicGFydFwifSAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgKX0gICAgICAgICAgICB7LyogR3JpZCAqL30gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGdhcC0zXCI+ICAgICAgICAgICAgICB7c3VicGFydHMubGVuZ3RoID4gMCAmJiBjYW5Qb3NpdGlvbiAmJiAoICAgICAgICAgICAgICAgIDxidXR0b24gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7ICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBzdWJwYXJ0cy5maW5kSW5kZXgoKHMpID0+IHMuaWQgPT09IHNlbGVjdGVkU3VicGFydElkKTsgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSBzZXRTZWxlY3RlZFN1YnBhcnRJZChzdWJwYXJ0c1tpZHggLSAxXS5pZCk7ICAgICAgICAgICAgICAgICAgfX0gICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IXNlbGVjdGVkU3VicGFydElkIHx8IHN1YnBhcnRzLmZpbmRJbmRleCgocykgPT4gcy5pZCA9PT0gc2VsZWN0ZWRTdWJwYXJ0SWQpID09PSAwfSAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTIgcHktMSBiZy1ncmF5LTIwMCB0ZXh0LWdyYXktNzAwIHJvdW5kZWQgaG92ZXI6YmctZ3JheS0zMDAgZGlzYWJsZWQ6b3BhY2l0eS01MCB0ZXh0LXhzXCIgICAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgICAgIFByZXYgICAgICAgICAgICAgICAgPC9idXR0b24+ICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgPGRpdiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJib3JkZXItMiBib3JkZXItZ3JheS00MDAgYmctZ3JhZGllbnQtdG8tYiBmcm9tLWFtYmVyLTEwMCB0by1hbWJlci01MCByZWxhdGl2ZSBteC1hdXRvXCIgICAgICAgICAgICAgICAgc3R5bGU9e3sgICAgICAgICAgICAgICAgICB3aWR0aDogR1JJRF9DT0xTICogQ0VMTF9TSVpFLCAgICAgICAgICAgICAgICAgIGhlaWdodDogR1JJRF9ST1dTICogQ0VMTF9TSVpFLCAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogYCAgICAgICAgICAgICAgICAgIGxpbmVhci1ncmFkaWVudChyZ2JhKDAsMCwwLC4xKSAxcHgsIHRyYW5zcGFyZW50IDFweCksICAgICAgICAgICAgICAgICAgbGluZWFyLWdyYWRpZW50KDkwZGVnLCByZ2JhKDAsMCwwLC4xKSAxcHgsIHRyYW5zcGFyZW50IDFweCkgICAgICAgICAgICAgICAgYCwgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kU2l6ZTogYCR7Q0VMTF9TSVpFfXB4ICR7Q0VMTF9TSVpFfXB4YCwgICAgICAgICAgICAgICAgfX0gICAgICAgICAgICAgICAgb25EcmFnT3Zlcj17aGFuZGxlR3JpZERyYWdPdmVyfSAgICAgICAgICAgICAgPiAgICAgICAgICAgICAgey8qIEZyb250IG9mIFN0YWdlIEluZGljYXRvciAqL30gICAgICAgICAgICAgIHtmcm9udERpcmVjdGlvbiA9PT0gXCJib3R0b21cIiAmJiAoICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgYm90dG9tLTAgbGVmdC0wIHJpZ2h0LTAgaC0xIGJnLXJlZC01MDBcIj48L2Rpdj4gICAgICAgICAgICAgICl9ICAgICAgICAgICAgICB7ZnJvbnREaXJlY3Rpb24gPT09IFwidG9wXCIgJiYgKCAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0wIGxlZnQtMCByaWdodC0wIGgtMSBiZy1yZWQtNTAwXCI+PC9kaXY+ICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgey8qIEZyb250IExhYmVsICovfSAgICAgICAgICAgICAgPGRpdiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0ZXh0LXJlZC02MDAgZm9udC1ib2xkIHRleHQteHMgYmctd2hpdGUgYmctb3BhY2l0eS04MCBweC0yIHB5LTEgcm91bmRlZFwiICAgICAgICAgICAgICAgIHN0eWxlPXt7ICAgICAgICAgICAgICAgICAgLi4uKGZyb250RGlyZWN0aW9uID09PSBcImJvdHRvbVwiICYmIHsgYm90dG9tOiA1LCBsZWZ0OiBcIjUwJVwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgtNTAlKVwiIH0pLCAgICAgICAgICAgICAgICAgIC4uLihmcm9udERpcmVjdGlvbiA9PT0gXCJ0b3BcIiAmJiB7IHRvcDogNSwgbGVmdDogXCI1MCVcIiwgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVgoLTUwJSlcIiB9KSwgICAgICAgICAgICAgICAgfX0gICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgRlJPTlQgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAge3NlbGVjdGVkU3VicGFydElkICYmIHN1YnBhcnRzLmxlbmd0aCA+IDAgJiYgYWN0aXZlUG9zaXRpb25zLmxlbmd0aCA9PT0gMCAmJiAoICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTggbGVmdC0wIHJpZ2h0LTAgdGV4dC1jZW50ZXIgdGV4dC0yeGwgZm9udC1ib2xkIHRleHQtZ3JheS01MDBcIj4gICAgICAgICAgICAgICAgICB7YWN0aXZlU3VicGFydD8udGl0bGUgfHwgXCJTdWJwYXJ0XCJ9ICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgKX0gICAgICAgICAgICAgIHsvKiBHcmlkIENlbGxzICovfSAgICAgICAgICAgICAge0FycmF5LmZyb20oeyBsZW5ndGg6IEdSSURfUk9XUyB9KS5tYXAoKF8sIHkpID0+ICAgICAgICAgICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IEdSSURfQ09MUyB9KS5tYXAoKF8sIHgpID0+ICggICAgICAgICAgICAgICAgICA8ZGl2ICAgICAgICAgICAgICAgICAgICBrZXk9e2Ake3h9LSR7eX1gfSAgICAgICAgICAgICAgICAgICAgb25Ecm9wPXsoZSkgPT4gaGFuZGxlR3JpZERyb3AoZSwgeCwgeSl9ICAgICAgICAgICAgICAgICAgICBvbkRyYWdPdmVyPXtoYW5kbGVHcmlkRHJhZ092ZXJ9ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBjdXJzb3ItY2VsbCBob3ZlcjpiZy1ibHVlLTEwMCBob3ZlcjpiZy1vcGFjaXR5LTMwIHRyYW5zaXRpb24tY29sb3JzXCIgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7ICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHggKiBDRUxMX1NJWkUsICAgICAgICAgICAgICAgICAgICAgIHRvcDogeSAqIENFTExfU0laRSwgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IENFTExfU0laRSwgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBDRUxMX1NJWkUsICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgIC8+ICAgICAgICAgICAgICAgICkpICAgICAgICAgICAgICApfSAgICAgICAgICAgICAgey8qIFBvc2l0aW9uZWQgU3R1ZGVudHMgKi99ICAgICAgICAgICAgICB7YWN0aXZlUG9zaXRpb25zLm1hcCgocG9zLCBpZHgpID0+IHsgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbHMgPSBnZW5lcmF0ZUluaXRpYWxzKHBvcy5uYW1lLCBhY3RpdmVQb3NpdGlvbnMubWFwKChwKSA9PiBwLm5hbWUpKTsgICAgICAgICAgICAgICAgcmV0dXJuICggICAgICAgICAgICAgICAgICA8ZGl2ICAgICAgICAgICAgICAgICAgICBrZXk9e3Bvcy5pZCB8fCBgJHtwb3Muc3R1ZGVudF9pZH0tJHtwb3MueH0tJHtwb3MueX0tJHtpZHh9YH0gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZSAgICAgICAgICAgICAgICAgICAgb25EcmFnU3RhcnQ9eygpID0+IGhhbmRsZURyYWdTdGFydChwb3Muc3R1ZGVudF9pZCwgdHJ1ZSl9ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBncm91cCBjdXJzb3ItbW92ZVwiICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0b0Rpc3BsYXlYKHBvcy54KSAqIENFTExfU0laRSwgICAgICAgICAgICAgICAgICAgICAgdG9wOiB0b0Rpc3BsYXlZKHBvcy55KSAqIENFTExfU0laRSwgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IENFTExfU0laRSwgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBDRUxMX1NJWkUsICAgICAgICAgICAgICAgICAgICB9fSAgICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgdy0xMCBoLTEwIGJnLWJsdWUtNTAwIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LXdoaXRlIHRleHQteHMgZm9udC1ib2xkIHNoYWRvdy1sZyBncm91cC1ob3ZlcjpiZy1ibHVlLTYwMCB0cmFuc2l0aW9uLWNvbG9yc1wiPiAgICAgICAgICAgICAgICAgICAgICB7aW5pdGlhbHN9ICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZW1vdmVGcm9tU3RhZ2UocG9zLnN0dWRlbnRfaWQpfSAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIC10b3AtMiAtcmlnaHQtMiBiZy1yZWQtNTAwIHRleHQtd2hpdGUgcm91bmRlZC1mdWxsIHctNSBoLTUgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdGV4dC14cyBvcGFjaXR5LTAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1vcGFjaXR5IGhvdmVyOmJnLXJlZC02MDBcIiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUmVtb3ZlIGZyb20gc3RhZ2VcIiAgICAgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICAgICAgeCAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBib3R0b20tZnVsbCBtYi0xIHdoaXRlc3BhY2Utbm93cmFwIGJnLWdyYXktOTAwIHRleHQtd2hpdGUgdGV4dC14cyBweS0xIHB4LTIgcm91bmRlZCBvcGFjaXR5LTAgZ3JvdXAtaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1vcGFjaXR5IHBvaW50ZXItZXZlbnRzLW5vbmVcIj4gICAgICAgICAgICAgICAgICAgICAge3Bvcy5uYW1lfSAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICk7ICAgICAgICAgICAgICB9KX0gICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAge3N1YnBhcnRzLmxlbmd0aCA+IDAgJiYgY2FuUG9zaXRpb24gJiYgKCAgICAgICAgICAgICAgICA8YnV0dG9uICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4geyAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gc3VicGFydHMuZmluZEluZGV4KChzKSA9PiBzLmlkID09PSBzZWxlY3RlZFN1YnBhcnRJZCk7ICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDwgc3VicGFydHMubGVuZ3RoIC0gMSkgc2V0U2VsZWN0ZWRTdWJwYXJ0SWQoc3VicGFydHNbaWR4ICsgMV0uaWQpOyAgICAgICAgICAgICAgICAgIH19ICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFzZWxlY3RlZFN1YnBhcnRJZCB8fCBzdWJwYXJ0cy5maW5kSW5kZXgoKHMpID0+IHMuaWQgPT09IHNlbGVjdGVkU3VicGFydElkKSA9PT0gc3VicGFydHMubGVuZ3RoIC0gMX0gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctZ3JheS0yMDAgdGV4dC1ncmF5LTcwMCByb3VuZGVkIGhvdmVyOmJnLWdyYXktMzAwIGRpc2FibGVkOm9wYWNpdHktNTAgdGV4dC14c1wiICAgICAgICAgICAgICAgID4gICAgICAgICAgICAgICAgICBOZXh0ICAgICAgICAgICAgICAgIDwvYnV0dG9uPiAgICAgICAgICAgICAgKX0gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICB7Y2FuT3JkZXIgJiYgc2VsZWN0ZWRTdWJwYXJ0SWQgJiYgbnVsbH0gICAgICAgICAgICB7LyogUG9zaXRpb25lZCBTdHVkZW50cyBMaXN0ICovfSAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS01MCBwLTQgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLWdyYXktMjAwXCI+ICAgICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1ncmF5LTkwMCBtYi0zXCI+ICAgICAgICAgICAgICAgIFBvc2l0aW9uZWQgKHthY3RpdmVQb3NpdGlvbnMubGVuZ3RofSkgICAgICAgICAgICAgIDwvaDQ+ICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgc206Z3JpZC1jb2xzLTMgZ2FwLTJcIj4gICAgICAgICAgICAgICAge2FjdGl2ZVBvc2l0aW9ucy5tYXAoKHBvcywgaWR4KSA9PiAoICAgICAgICAgICAgICAgICAgPGRpdiAgICAgICAgICAgICAgICAgICAga2V5PXtwb3MuaWQgfHwgYCR7cG9zLnN0dWRlbnRfaWR9LSR7cG9zLnh9LSR7cG9zLnl9LSR7aWR4fWB9ICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy13aGl0ZSBwLTIgcm91bmRlZCBib3JkZXIgYm9yZGVyLWdyZWVuLTIwMCB0ZXh0LXNtXCIgICAgICAgICAgICAgICAgICA+ICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0ZXh0LWdyYXktOTAwXCI+e3Bvcy5uYW1lfTwvcD4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTYwMFwiPiAgICAgICAgICAgICAgICAgICAgICAoe3Bvcy54fSwge3Bvcy55fSkgICAgICAgICAgICAgICAgICAgIDwvcD4gICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgKSl9ICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgPC9kaXY+ICAgICAgICA8L2Rpdj4gICAgICA8L2Rpdj4gICAgPC9kaXY+ICApO30iXSwibmFtZXMiOlsiUmVhY3QiLCJHUklEX0NPTFMiLCJHUklEX1JPV1MiLCJDRUxMX1NJWkUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/PositioningPanel.tsx\n"));

/***/ })

});