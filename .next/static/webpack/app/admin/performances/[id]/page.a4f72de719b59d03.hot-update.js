"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/performances/[id]/page",{

/***/ "(app-pages-browser)/./src/lib/datetime.ts":
/*!*****************************!*\
  !*** ./src/lib/datetime.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_TIMEZONE: () => (/* binding */ DEFAULT_TIMEZONE),\n/* harmony export */   formatDateTimeLocalInTimeZone: () => (/* binding */ formatDateTimeLocalInTimeZone),\n/* harmony export */   formatDisplayDateTime: () => (/* binding */ formatDisplayDateTime),\n/* harmony export */   formatDisplayDateTimeWithWeekday: () => (/* binding */ formatDisplayDateTimeWithWeekday),\n/* harmony export */   formatTimeInTimeZone: () => (/* binding */ formatTimeInTimeZone),\n/* harmony export */   formatTimeString: () => (/* binding */ formatTimeString),\n/* harmony export */   getCallTimeFromDateTimeLocal: () => (/* binding */ getCallTimeFromDateTimeLocal),\n/* harmony export */   getDateKeyInTimeZone: () => (/* binding */ getDateKeyInTimeZone),\n/* harmony export */   isCallTimeLocked: () => (/* binding */ isCallTimeLocked),\n/* harmony export */   parseDateTimeLocal: () => (/* binding */ parseDateTimeLocal),\n/* harmony export */   zonedDateTimeLocalToUtcIso: () => (/* binding */ zonedDateTimeLocalToUtcIso)\n/* harmony export */ });\nconst DEFAULT_TIMEZONE = \"America/New_York\";\nconst hasTimeZoneInfo = (value)=>/[zZ]|[+-]\\d{2}:\\d{2}$/.test(value);\nconst parseNaiveDateTime = (value)=>{\n    if (!value) return null;\n    const [datePart, timePartRaw] = value.split(/[T ]/);\n    if (!datePart || !timePartRaw) return null;\n    const timePart = timePartRaw.slice(0, 5);\n    const [yearStr, monthStr, dayStr] = datePart.split(\"-\");\n    const [hourStr, minuteStr] = timePart.split(\":\");\n    const year = Number(yearStr);\n    const month = Number(monthStr);\n    const day = Number(dayStr);\n    const hour = Number(hourStr);\n    const minute = Number(minuteStr);\n    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day) || !Number.isFinite(hour) || !Number.isFinite(minute)) {\n        return null;\n    }\n    return {\n        datePart,\n        timePart,\n        year,\n        month,\n        day,\n        hour,\n        minute\n    };\n};\nfunction parseDateTimeLocal(value) {\n    if (!value) return null;\n    const [datePart, timePart] = value.split(\"T\");\n    if (!datePart || !timePart) return null;\n    const [yearStr, monthStr, dayStr] = datePart.split(\"-\");\n    const [hourStr, minuteStr] = timePart.split(\":\");\n    const year = Number(yearStr);\n    const month = Number(monthStr);\n    const day = Number(dayStr);\n    const hour = Number(hourStr);\n    const minute = Number(minuteStr);\n    if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day) || !Number.isFinite(hour) || !Number.isFinite(minute)) {\n        return null;\n    }\n    return {\n        year,\n        month,\n        day,\n        hour,\n        minute\n    };\n}\nfunction getTimeZoneOffsetMs(timeZone, date) {\n    const dtf = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        second: \"2-digit\",\n        hour12: false\n    });\n    const parts = dtf.formatToParts(date);\n    const lookup = {};\n    for (const part of parts){\n        if (part.type !== \"literal\") {\n            lookup[part.type] = part.value;\n        }\n    }\n    const asUtc = Date.UTC(Number(lookup.year), Number(lookup.month) - 1, Number(lookup.day), Number(lookup.hour), Number(lookup.minute), Number(lookup.second));\n    return asUtc - date.getTime();\n}\nfunction zonedDateTimeLocalToUtcIso(localValue, timeZone) {\n    const parts = parseDateTimeLocal(localValue);\n    if (!parts) return \"\";\n    const utcGuess = new Date(Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, 0));\n    const offset = getTimeZoneOffsetMs(timeZone, utcGuess);\n    const actualUtc = new Date(utcGuess.getTime() - offset);\n    return actualUtc.toISOString();\n}\nfunction formatDateTimeLocalInTimeZone(isoValue, timeZone) {\n    if (!isoValue) return \"\";\n    if (!hasTimeZoneInfo(isoValue)) {\n        const parsed = parseNaiveDateTime(isoValue);\n        return parsed ? \"\".concat(parsed.datePart, \"T\").concat(parsed.timePart) : isoValue;\n    }\n    const date = new Date(isoValue);\n    if (Number.isNaN(date.getTime())) return \"\";\n    const dtf = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\",\n        hour: \"2-digit\",\n        minute: \"2-digit\",\n        hour12: false\n    });\n    const parts = dtf.formatToParts(date);\n    const lookup = {};\n    for (const part of parts){\n        if (part.type !== \"literal\") {\n            lookup[part.type] = part.value;\n        }\n    }\n    return \"\".concat(lookup.year, \"-\").concat(lookup.month, \"-\").concat(lookup.day, \"T\").concat(lookup.hour, \":\").concat(lookup.minute);\n}\nfunction formatDisplayDateTime(isoValue, timeZone) {\n    if (!isoValue) return \"—\";\n    if (!hasTimeZoneInfo(isoValue)) {\n        const parsed = parseNaiveDateTime(isoValue);\n        if (!parsed) return isoValue;\n        const dateUtc = new Date(Date.UTC(parsed.year, parsed.month - 1, parsed.day, parsed.hour, parsed.minute, 0));\n        const dateLabel = dateUtc.toLocaleDateString(undefined, {\n            timeZone: \"UTC\"\n        });\n        const timeLabel = dateUtc.toLocaleTimeString(undefined, {\n            timeZone: \"UTC\",\n            hour: \"numeric\",\n            minute: \"2-digit\"\n        });\n        return \"\".concat(dateLabel, \", \").concat(timeLabel, \" ET\");\n    }\n    const date = new Date(isoValue);\n    if (Number.isNaN(date.getTime())) return \"—\";\n    return date.toLocaleString(undefined, {\n        timeZone: timeZone || DEFAULT_TIMEZONE,\n        timeZoneName: \"short\"\n    });\n}\nfunction formatDisplayDateTimeWithWeekday(isoValue, timeZone) {\n    if (!isoValue) return \"â€”\";\n    if (!hasTimeZoneInfo(isoValue)) {\n        const parsed = parseNaiveDateTime(isoValue);\n        if (!parsed) return isoValue;\n        const dateUtc = new Date(Date.UTC(parsed.year, parsed.month - 1, parsed.day, parsed.hour, parsed.minute, 0));\n        const label = dateUtc.toLocaleString(undefined, {\n            timeZone: \"UTC\",\n            weekday: \"long\",\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\",\n            hour: \"numeric\",\n            minute: \"2-digit\"\n        });\n        return \"\".concat(label, \" ET\");\n    }\n    const date = new Date(isoValue);\n    if (Number.isNaN(date.getTime())) return \"â€”\";\n    return date.toLocaleString(undefined, {\n        timeZone: timeZone || DEFAULT_TIMEZONE,\n        weekday: \"long\",\n        year: \"numeric\",\n        month: \"short\",\n        day: \"numeric\",\n        hour: \"numeric\",\n        minute: \"2-digit\",\n        timeZoneName: \"short\"\n    });\n}\nfunction formatTimeInTimeZone(isoValue, timeZone) {\n    if (!isoValue) return \"—\";\n    if (!hasTimeZoneInfo(isoValue)) {\n        const parsed = parseNaiveDateTime(isoValue);\n        return parsed ? formatTimeString(parsed.timePart) : isoValue;\n    }\n    const date = new Date(isoValue);\n    if (Number.isNaN(date.getTime())) return \"—\";\n    return date.toLocaleTimeString(undefined, {\n        timeZone: timeZone || DEFAULT_TIMEZONE,\n        hour: \"numeric\",\n        minute: \"2-digit\"\n    });\n}\nfunction getDateKeyInTimeZone(isoValue, timeZone) {\n    if (!isoValue) return \"\";\n    if (!hasTimeZoneInfo(isoValue)) {\n        const parsed = parseNaiveDateTime(isoValue);\n        return parsed ? parsed.datePart : \"\";\n    }\n    const date = new Date(isoValue);\n    if (Number.isNaN(date.getTime())) return \"\";\n    const dtf = new Intl.DateTimeFormat(\"en-US\", {\n        timeZone: timeZone || DEFAULT_TIMEZONE,\n        year: \"numeric\",\n        month: \"2-digit\",\n        day: \"2-digit\"\n    });\n    const parts = dtf.formatToParts(date);\n    const lookup = {};\n    for (const part of parts){\n        if (part.type !== \"literal\") {\n            lookup[part.type] = part.value;\n        }\n    }\n    return \"\".concat(lookup.year, \"-\").concat(lookup.month, \"-\").concat(lookup.day);\n}\nfunction formatTimeString(value) {\n    if (!value) return \"—\";\n    const [hourStr, minuteStr] = value.split(\":\");\n    const hour = Number(hourStr);\n    const minute = Number(minuteStr);\n    if (!Number.isFinite(hour) || !Number.isFinite(minute)) return value;\n    const date = new Date(Date.UTC(2000, 0, 1, hour, minute, 0));\n    return date.toLocaleTimeString(undefined, {\n        hour: \"numeric\",\n        minute: \"2-digit\",\n        timeZone: \"UTC\"\n    });\n}\nfunction getCallTimeFromDateTimeLocal(value) {\n    const parts = parseDateTimeLocal(value);\n    if (!parts) return \"\";\n    const baseUtc = new Date(Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, 0));\n    baseUtc.setUTCHours(baseUtc.getUTCHours() - 1);\n    const hour = String(baseUtc.getUTCHours()).padStart(2, \"0\");\n    const minute = String(baseUtc.getUTCMinutes()).padStart(2, \"0\");\n    return \"\".concat(hour, \":\").concat(minute);\n}\nfunction isCallTimeLocked(localValue, timeZone) {\n    if (!localValue) return false;\n    const utcIso = zonedDateTimeLocalToUtcIso(localValue, timeZone);\n    const perfDate = new Date(utcIso);\n    if (Number.isNaN(perfDate.getTime())) return false;\n    const lockAt = perfDate.getTime() - 60 * 60 * 1000;\n    return Date.now() >= lockAt;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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akI7SUFDdEQsTUFBTWtELFdBQVcsSUFBSXJDLEtBQUtvQztJQUMxQixJQUFJekQsT0FBT2lDLEtBQUssQ0FBQ3lCLFNBQVNuQyxPQUFPLEtBQUssT0FBTztJQUM3QyxNQUFNb0MsU0FBU0QsU0FBU25DLE9BQU8sS0FBSyxLQUFLLEtBQUs7SUFDOUMsT0FBT0YsS0FBS3VDLEdBQUcsTUFBTUQ7QUFDdkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2FsdmlcXERlc2t0b3BcXFBlcmZUb29sXFxzcmNcXGxpYlxcZGF0ZXRpbWUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBEYXRlVGltZUxvY2FsUGFydHMge1xuICB5ZWFyOiBudW1iZXI7XG4gIG1vbnRoOiBudW1iZXI7XG4gIGRheTogbnVtYmVyO1xuICBob3VyOiBudW1iZXI7XG4gIG1pbnV0ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FWk9ORSA9IFwiQW1lcmljYS9OZXdfWW9ya1wiO1xuXG5jb25zdCBoYXNUaW1lWm9uZUluZm8gPSAodmFsdWU6IHN0cmluZykgPT4gL1t6Wl18WystXVxcZHsyfTpcXGR7Mn0kLy50ZXN0KHZhbHVlKTtcblxuY29uc3QgcGFyc2VOYWl2ZURhdGVUaW1lID0gKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFtkYXRlUGFydCwgdGltZVBhcnRSYXddID0gdmFsdWUuc3BsaXQoL1tUIF0vKTtcbiAgaWYgKCFkYXRlUGFydCB8fCAhdGltZVBhcnRSYXcpIHJldHVybiBudWxsO1xuICBjb25zdCB0aW1lUGFydCA9IHRpbWVQYXJ0UmF3LnNsaWNlKDAsIDUpO1xuICBjb25zdCBbeWVhclN0ciwgbW9udGhTdHIsIGRheVN0cl0gPSBkYXRlUGFydC5zcGxpdChcIi1cIik7XG4gIGNvbnN0IFtob3VyU3RyLCBtaW51dGVTdHJdID0gdGltZVBhcnQuc3BsaXQoXCI6XCIpO1xuICBjb25zdCB5ZWFyID0gTnVtYmVyKHllYXJTdHIpO1xuICBjb25zdCBtb250aCA9IE51bWJlcihtb250aFN0cik7XG4gIGNvbnN0IGRheSA9IE51bWJlcihkYXlTdHIpO1xuICBjb25zdCBob3VyID0gTnVtYmVyKGhvdXJTdHIpO1xuICBjb25zdCBtaW51dGUgPSBOdW1iZXIobWludXRlU3RyKTtcbiAgaWYgKFxuICAgICFOdW1iZXIuaXNGaW5pdGUoeWVhcikgfHxcbiAgICAhTnVtYmVyLmlzRmluaXRlKG1vbnRoKSB8fFxuICAgICFOdW1iZXIuaXNGaW5pdGUoZGF5KSB8fFxuICAgICFOdW1iZXIuaXNGaW5pdGUoaG91cikgfHxcbiAgICAhTnVtYmVyLmlzRmluaXRlKG1pbnV0ZSlcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHsgZGF0ZVBhcnQsIHRpbWVQYXJ0LCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGVUaW1lTG9jYWwodmFsdWU6IHN0cmluZyk6IERhdGVUaW1lTG9jYWxQYXJ0cyB8IG51bGwge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgW2RhdGVQYXJ0LCB0aW1lUGFydF0gPSB2YWx1ZS5zcGxpdChcIlRcIik7XG4gIGlmICghZGF0ZVBhcnQgfHwgIXRpbWVQYXJ0KSByZXR1cm4gbnVsbDtcbiAgY29uc3QgW3llYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHJdID0gZGF0ZVBhcnQuc3BsaXQoXCItXCIpO1xuICBjb25zdCBbaG91clN0ciwgbWludXRlU3RyXSA9IHRpbWVQYXJ0LnNwbGl0KFwiOlwiKTtcbiAgY29uc3QgeWVhciA9IE51bWJlcih5ZWFyU3RyKTtcbiAgY29uc3QgbW9udGggPSBOdW1iZXIobW9udGhTdHIpO1xuICBjb25zdCBkYXkgPSBOdW1iZXIoZGF5U3RyKTtcbiAgY29uc3QgaG91ciA9IE51bWJlcihob3VyU3RyKTtcbiAgY29uc3QgbWludXRlID0gTnVtYmVyKG1pbnV0ZVN0cik7XG4gIGlmIChcbiAgICAhTnVtYmVyLmlzRmluaXRlKHllYXIpIHx8XG4gICAgIU51bWJlci5pc0Zpbml0ZShtb250aCkgfHxcbiAgICAhTnVtYmVyLmlzRmluaXRlKGRheSkgfHxcbiAgICAhTnVtYmVyLmlzRmluaXRlKGhvdXIpIHx8XG4gICAgIU51bWJlci5pc0Zpbml0ZShtaW51dGUpXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSB9O1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lWm9uZU9mZnNldE1zKHRpbWVab25lOiBzdHJpbmcsIGRhdGU6IERhdGUpOiBudW1iZXIge1xuICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICB0aW1lWm9uZSxcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgaG91cjEyOiBmYWxzZSxcbiAgfSk7XG4gIGNvbnN0IHBhcnRzID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGxvb2t1cDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICBpZiAocGFydC50eXBlICE9PSBcImxpdGVyYWxcIikge1xuICAgICAgbG9va3VwW3BhcnQudHlwZV0gPSBwYXJ0LnZhbHVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBhc1V0YyA9IERhdGUuVVRDKFxuICAgIE51bWJlcihsb29rdXAueWVhciksXG4gICAgTnVtYmVyKGxvb2t1cC5tb250aCkgLSAxLFxuICAgIE51bWJlcihsb29rdXAuZGF5KSxcbiAgICBOdW1iZXIobG9va3VwLmhvdXIpLFxuICAgIE51bWJlcihsb29rdXAubWludXRlKSxcbiAgICBOdW1iZXIobG9va3VwLnNlY29uZClcbiAgKTtcbiAgcmV0dXJuIGFzVXRjIC0gZGF0ZS5nZXRUaW1lKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6b25lZERhdGVUaW1lTG9jYWxUb1V0Y0lzbyhsb2NhbFZhbHVlOiBzdHJpbmcsIHRpbWVab25lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0cyA9IHBhcnNlRGF0ZVRpbWVMb2NhbChsb2NhbFZhbHVlKTtcbiAgaWYgKCFwYXJ0cykgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHV0Y0d1ZXNzID0gbmV3IERhdGUoXG4gICAgRGF0ZS5VVEMocGFydHMueWVhciwgcGFydHMubW9udGggLSAxLCBwYXJ0cy5kYXksIHBhcnRzLmhvdXIsIHBhcnRzLm1pbnV0ZSwgMClcbiAgKTtcbiAgY29uc3Qgb2Zmc2V0ID0gZ2V0VGltZVpvbmVPZmZzZXRNcyh0aW1lWm9uZSwgdXRjR3Vlc3MpO1xuICBjb25zdCBhY3R1YWxVdGMgPSBuZXcgRGF0ZSh1dGNHdWVzcy5nZXRUaW1lKCkgLSBvZmZzZXQpO1xuICByZXR1cm4gYWN0dWFsVXRjLnRvSVNPU3RyaW5nKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlVGltZUxvY2FsSW5UaW1lWm9uZShpc29WYWx1ZTogc3RyaW5nLCB0aW1lWm9uZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc29WYWx1ZSkgcmV0dXJuIFwiXCI7XG4gIGlmICghaGFzVGltZVpvbmVJbmZvKGlzb1ZhbHVlKSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTmFpdmVEYXRlVGltZShpc29WYWx1ZSk7XG4gICAgcmV0dXJuIHBhcnNlZCA/IGAke3BhcnNlZC5kYXRlUGFydH1UJHtwYXJzZWQudGltZVBhcnR9YCA6IGlzb1ZhbHVlO1xuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29WYWx1ZSk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSByZXR1cm4gXCJcIjtcbiAgY29uc3QgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7XG4gICAgdGltZVpvbmUsXG4gICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgIGRheTogXCIyLWRpZ2l0XCIsXG4gICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICBob3VyMTI6IGZhbHNlLFxuICB9KTtcbiAgY29uc3QgcGFydHMgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgbG9va3VwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChwYXJ0LnR5cGUgIT09IFwibGl0ZXJhbFwiKSB7XG4gICAgICBsb29rdXBbcGFydC50eXBlXSA9IHBhcnQudmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBgJHtsb29rdXAueWVhcn0tJHtsb29rdXAubW9udGh9LSR7bG9va3VwLmRheX1UJHtsb29rdXAuaG91cn06JHtsb29rdXAubWludXRlfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREaXNwbGF5RGF0ZVRpbWUoaXNvVmFsdWU6IHN0cmluZywgdGltZVpvbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghaXNvVmFsdWUpIHJldHVybiBcIuKAlFwiO1xuICBpZiAoIWhhc1RpbWVab25lSW5mbyhpc29WYWx1ZSkpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZU5haXZlRGF0ZVRpbWUoaXNvVmFsdWUpO1xuICAgIGlmICghcGFyc2VkKSByZXR1cm4gaXNvVmFsdWU7XG4gICAgY29uc3QgZGF0ZVV0YyA9IG5ldyBEYXRlKERhdGUuVVRDKHBhcnNlZC55ZWFyLCBwYXJzZWQubW9udGggLSAxLCBwYXJzZWQuZGF5LCBwYXJzZWQuaG91ciwgcGFyc2VkLm1pbnV0ZSwgMCkpO1xuICAgIGNvbnN0IGRhdGVMYWJlbCA9IGRhdGVVdGMudG9Mb2NhbGVEYXRlU3RyaW5nKHVuZGVmaW5lZCwgeyB0aW1lWm9uZTogXCJVVENcIiB9KTtcbiAgICBjb25zdCB0aW1lTGFiZWwgPSBkYXRlVXRjLnRvTG9jYWxlVGltZVN0cmluZyh1bmRlZmluZWQsIHtcbiAgICAgIHRpbWVab25lOiBcIlVUQ1wiLFxuICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH0pO1xuICAgIHJldHVybiBgJHtkYXRlTGFiZWx9LCAke3RpbWVMYWJlbH0gRVRgO1xuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29WYWx1ZSk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSByZXR1cm4gXCLigJRcIjtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7XG4gICAgdGltZVpvbmU6IHRpbWVab25lIHx8IERFRkFVTFRfVElNRVpPTkUsXG4gICAgdGltZVpvbmVOYW1lOiBcInNob3J0XCIsXG4gIH0pO1xufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERpc3BsYXlEYXRlVGltZVdpdGhXZWVrZGF5KGlzb1ZhbHVlOiBzdHJpbmcsIHRpbWVab25lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWlzb1ZhbHVlKSByZXR1cm4gXCLDouKCrOKAnVwiO1xuICBpZiAoIWhhc1RpbWVab25lSW5mbyhpc29WYWx1ZSkpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZU5haXZlRGF0ZVRpbWUoaXNvVmFsdWUpO1xuICAgIGlmICghcGFyc2VkKSByZXR1cm4gaXNvVmFsdWU7XG4gICAgY29uc3QgZGF0ZVV0YyA9IG5ldyBEYXRlKERhdGUuVVRDKHBhcnNlZC55ZWFyLCBwYXJzZWQubW9udGggLSAxLCBwYXJzZWQuZGF5LCBwYXJzZWQuaG91ciwgcGFyc2VkLm1pbnV0ZSwgMCkpO1xuICAgIGNvbnN0IGxhYmVsID0gZGF0ZVV0Yy50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHtcbiAgICAgIHRpbWVab25lOiBcIlVUQ1wiLFxuICAgICAgd2Vla2RheTogXCJsb25nXCIsXG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcInNob3J0XCIsXG4gICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH0pO1xuICAgIHJldHVybiBgJHtsYWJlbH0gRVRgO1xuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29WYWx1ZSk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSByZXR1cm4gXCLDouKCrOKAnVwiO1xuICByZXR1cm4gZGF0ZS50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHtcbiAgICB0aW1lWm9uZTogdGltZVpvbmUgfHwgREVGQVVMVF9USU1FWk9ORSxcbiAgICB3ZWVrZGF5OiBcImxvbmdcIixcbiAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICBtb250aDogXCJzaG9ydFwiLFxuICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB0aW1lWm9uZU5hbWU6IFwic2hvcnRcIixcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lSW5UaW1lWm9uZShpc29WYWx1ZTogc3RyaW5nLCB0aW1lWm9uZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc29WYWx1ZSkgcmV0dXJuIFwi4oCUXCI7XG4gIGlmICghaGFzVGltZVpvbmVJbmZvKGlzb1ZhbHVlKSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTmFpdmVEYXRlVGltZShpc29WYWx1ZSk7XG4gICAgcmV0dXJuIHBhcnNlZCA/IGZvcm1hdFRpbWVTdHJpbmcocGFyc2VkLnRpbWVQYXJ0KSA6IGlzb1ZhbHVlO1xuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShpc29WYWx1ZSk7XG4gIGlmIChOdW1iZXIuaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSByZXR1cm4gXCLigJRcIjtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKHVuZGVmaW5lZCwge1xuICAgIHRpbWVab25lOiB0aW1lWm9uZSB8fCBERUZBVUxUX1RJTUVaT05FLFxuICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gIH0pO1xufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGVLZXlJblRpbWVab25lKGlzb1ZhbHVlOiBzdHJpbmcsIHRpbWVab25lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWlzb1ZhbHVlKSByZXR1cm4gXCJcIjtcbiAgaWYgKCFoYXNUaW1lWm9uZUluZm8oaXNvVmFsdWUpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VOYWl2ZURhdGVUaW1lKGlzb1ZhbHVlKTtcbiAgICByZXR1cm4gcGFyc2VkID8gcGFyc2VkLmRhdGVQYXJ0IDogXCJcIjtcbiAgfVxuICBjb25zdCBkYXRlID0gbmV3IERhdGUoaXNvVmFsdWUpO1xuICBpZiAoTnVtYmVyLmlzTmFOKGRhdGUuZ2V0VGltZSgpKSkgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwge1xuICAgIHRpbWVab25lOiB0aW1lWm9uZSB8fCBERUZBVUxUX1RJTUVaT05FLFxuICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgIG1vbnRoOiBcIjItZGlnaXRcIixcbiAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICB9KTtcbiAgY29uc3QgcGFydHMgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKTtcbiAgY29uc3QgbG9va3VwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChwYXJ0LnR5cGUgIT09IFwibGl0ZXJhbFwiKSB7XG4gICAgICBsb29rdXBbcGFydC50eXBlXSA9IHBhcnQudmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBgJHtsb29rdXAueWVhcn0tJHtsb29rdXAubW9udGh9LSR7bG9va3VwLmRheX1gO1xufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVTdHJpbmcodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghdmFsdWUpIHJldHVybiBcIuKAlFwiO1xuICBjb25zdCBbaG91clN0ciwgbWludXRlU3RyXSA9IHZhbHVlLnNwbGl0KFwiOlwiKTtcbiAgY29uc3QgaG91ciA9IE51bWJlcihob3VyU3RyKTtcbiAgY29uc3QgbWludXRlID0gTnVtYmVyKG1pbnV0ZVN0cik7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGhvdXIpIHx8ICFOdW1iZXIuaXNGaW5pdGUobWludXRlKSkgcmV0dXJuIHZhbHVlO1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoMjAwMCwgMCwgMSwgaG91ciwgbWludXRlLCAwKSk7XG4gIHJldHVybiBkYXRlLnRvTG9jYWxlVGltZVN0cmluZyh1bmRlZmluZWQsIHtcbiAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIHRpbWVab25lOiBcIlVUQ1wiLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldENhbGxUaW1lRnJvbURhdGVUaW1lTG9jYWwodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcnRzID0gcGFyc2VEYXRlVGltZUxvY2FsKHZhbHVlKTtcbiAgaWYgKCFwYXJ0cykgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IGJhc2VVdGMgPSBuZXcgRGF0ZShcbiAgICBEYXRlLlVUQyhwYXJ0cy55ZWFyLCBwYXJ0cy5tb250aCAtIDEsIHBhcnRzLmRheSwgcGFydHMuaG91ciwgcGFydHMubWludXRlLCAwKVxuICApO1xuICBiYXNlVXRjLnNldFVUQ0hvdXJzKGJhc2VVdGMuZ2V0VVRDSG91cnMoKSAtIDEpO1xuICBjb25zdCBob3VyID0gU3RyaW5nKGJhc2VVdGMuZ2V0VVRDSG91cnMoKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICBjb25zdCBtaW51dGUgPSBTdHJpbmcoYmFzZVV0Yy5nZXRVVENNaW51dGVzKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgcmV0dXJuIGAke2hvdXJ9OiR7bWludXRlfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbGxUaW1lTG9ja2VkKGxvY2FsVmFsdWU6IHN0cmluZywgdGltZVpvbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIWxvY2FsVmFsdWUpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdXRjSXNvID0gem9uZWREYXRlVGltZUxvY2FsVG9VdGNJc28obG9jYWxWYWx1ZSwgdGltZVpvbmUpO1xuICBjb25zdCBwZXJmRGF0ZSA9IG5ldyBEYXRlKHV0Y0lzbyk7XG4gIGlmIChOdW1iZXIuaXNOYU4ocGVyZkRhdGUuZ2V0VGltZSgpKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBsb2NrQXQgPSBwZXJmRGF0ZS5nZXRUaW1lKCkgLSA2MCAqIDYwICogMTAwMDtcbiAgcmV0dXJuIERhdGUubm93KCkgPj0gbG9ja0F0O1xufVxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfVElNRVpPTkUiLCJoYXNUaW1lWm9uZUluZm8iLCJ2YWx1ZSIsInRlc3QiLCJwYXJzZU5haXZlRGF0ZVRpbWUiLCJkYXRlUGFydCIsInRpbWVQYXJ0UmF3Iiwic3BsaXQiLCJ0aW1lUGFydCIsInNsaWNlIiwieWVhclN0ciIsIm1vbnRoU3RyIiwiZGF5U3RyIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInllYXIiLCJOdW1iZXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJpc0Zpbml0ZSIsInBhcnNlRGF0ZVRpbWVMb2NhbCIsImdldFRpbWVab25lT2Zmc2V0TXMiLCJ0aW1lWm9uZSIsImRhdGUiLCJkdGYiLCJJbnRsIiwiRGF0ZVRpbWVGb3JtYXQiLCJzZWNvbmQiLCJob3VyMTIiLCJwYXJ0cyIsImZvcm1hdFRvUGFydHMiLCJsb29rdXAiLCJwYXJ0IiwidHlwZSIsImFzVXRjIiwiRGF0ZSIsIlVUQyIsImdldFRpbWUiLCJ6b25lZERhdGVUaW1lTG9jYWxUb1V0Y0lzbyIsImxvY2FsVmFsdWUiLCJ1dGNHdWVzcyIsIm9mZnNldCIsImFjdHVhbFV0YyIsInRvSVNPU3RyaW5nIiwiZm9ybWF0RGF0ZVRpbWVMb2NhbEluVGltZVpvbmUiLCJpc29WYWx1ZSIsInBhcnNlZCIsImlzTmFOIiwiZm9ybWF0RGlzcGxheURhdGVUaW1lIiwiZGF0ZVV0YyIsImRhdGVMYWJlbCIsInRvTG9jYWxlRGF0ZVN0cmluZyIsInVuZGVmaW5lZCIsInRpbWVMYWJlbCIsInRvTG9jYWxlVGltZVN0cmluZyIsInRvTG9jYWxlU3RyaW5nIiwidGltZVpvbmVOYW1lIiwiZm9ybWF0RGlzcGxheURhdGVUaW1lV2l0aFdlZWtkYXkiLCJsYWJlbCIsIndlZWtkYXkiLCJmb3JtYXRUaW1lSW5UaW1lWm9uZSIsImZvcm1hdFRpbWVTdHJpbmciLCJnZXREYXRlS2V5SW5UaW1lWm9uZSIsImdldENhbGxUaW1lRnJvbURhdGVUaW1lTG9jYWwiLCJiYXNlVXRjIiwic2V0VVRDSG91cnMiLCJnZXRVVENIb3VycyIsIlN0cmluZyIsInBhZFN0YXJ0IiwiZ2V0VVRDTWludXRlcyIsImlzQ2FsbFRpbWVMb2NrZWQiLCJ1dGNJc28iLCJwZXJmRGF0ZSIsImxvY2tBdCIsIm5vdyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/datetime.ts\n"));

/***/ })

});